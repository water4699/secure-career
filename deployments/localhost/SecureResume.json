{
  "address": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "hr",
          "type": "address"
        }
      ],
      "name": "HRAuthorized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "hr",
          "type": "address"
        }
      ],
      "name": "HRRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ResumeSubmitted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "ResumeUpdated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hr",
          "type": "address"
        }
      ],
      "name": "authorizeHR",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "skillIndices",
          "type": "uint256[]"
        }
      ],
      "name": "calculateSkillScore",
      "outputs": [
        {
          "internalType": "euint32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "candidate",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "skillIndex",
          "type": "uint256"
        }
      ],
      "name": "evaluateSkillMatch",
      "outputs": [
        {
          "internalType": "euint32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getResumeInfo",
      "outputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "education",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "workExperience",
          "type": "string"
        },
        {
          "internalType": "string[]",
          "name": "skillNames",
          "type": "string[]"
        },
        {
          "internalType": "uint64",
          "name": "createdAt",
          "type": "uint64"
        },
        {
          "internalType": "uint64",
          "name": "updatedAt",
          "type": "uint64"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getSkillLevels",
      "outputs": [
        {
          "internalType": "euint32[]",
          "name": "",
          "type": "bytes32[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getStats",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalResumes",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "hasResume",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "hrAddresses",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "protocolId",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "hr",
          "type": "address"
        }
      ],
      "name": "revokeHR",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "education",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "workExperience",
          "type": "string"
        },
        {
          "internalType": "string[]",
          "name": "skillNames",
          "type": "string[]"
        },
        {
          "internalType": "externalEuint32[]",
          "name": "skillLevelsExt",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "submitResume",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "education",
          "type": "string"
        },
        {
          "internalType": "string",
          "name": "workExperience",
          "type": "string"
        },
        {
          "internalType": "string[]",
          "name": "skillNames",
          "type": "string[]"
        },
        {
          "internalType": "externalEuint32[]",
          "name": "skillLevelsExt",
          "type": "bytes32[]"
        },
        {
          "internalType": "bytes",
          "name": "inputProof",
          "type": "bytes"
        }
      ],
      "name": "updateResume",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x0ed0c1b96b078cafaf58817d4c1226e7201682e3375f98ee827167abc37792b5",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x5FbDB2315678afecb367f032d93F642f64180aa3",
    "transactionIndex": 0,
    "gasUsed": "2064713",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x359bb44fd9505291cb89b6adfb642f97fccb148aa9ae3fb750d280e1ac4badbd",
    "transactionHash": "0x0ed0c1b96b078cafaf58817d4c1226e7201682e3375f98ee827167abc37792b5",
    "logs": [],
    "blockNumber": 3,
    "cumulativeGasUsed": "2064713",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "39a6f5751fb86c7d6ad77fe383f74ac4",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hr\",\"type\":\"address\"}],\"name\":\"HRAuthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hr\",\"type\":\"address\"}],\"name\":\"HRRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ResumeSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"ResumeUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hr\",\"type\":\"address\"}],\"name\":\"authorizeHR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"skillIndices\",\"type\":\"uint256[]\"}],\"name\":\"calculateSkillScore\",\"outputs\":[{\"internalType\":\"euint32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"skillIndex\",\"type\":\"uint256\"}],\"name\":\"evaluateSkillMatch\",\"outputs\":[{\"internalType\":\"euint32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getResumeInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"education\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"workExperience\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"skillNames\",\"type\":\"string[]\"},{\"internalType\":\"uint64\",\"name\":\"createdAt\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"updatedAt\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getSkillLevels\",\"outputs\":[{\"internalType\":\"euint32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalResumes\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"hasResume\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hrAddresses\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hr\",\"type\":\"address\"}],\"name\":\"revokeHR\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"education\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"workExperience\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"skillNames\",\"type\":\"string[]\"},{\"internalType\":\"externalEuint32[]\",\"name\":\"skillLevelsExt\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"submitResume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"education\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"workExperience\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"skillNames\",\"type\":\"string[]\"},{\"internalType\":\"externalEuint32[]\",\"name\":\"skillLevelsExt\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes\",\"name\":\"inputProof\",\"type\":\"bytes\"}],\"name\":\"updateResume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Uses FHEVM to enable encrypted skill matching without decryption\",\"kind\":\"dev\",\"methods\":{\"authorizeHR(address)\":{\"params\":{\"hr\":\"HR address to authorize\"}},\"calculateSkillScore(address,uint256[])\":{\"details\":\"Performs encrypted addition without decrypting individual levels\",\"params\":{\"candidate\":\"Candidate address\",\"skillIndices\":\"Array of skill indices to include in score (0-4)\"},\"returns\":{\"_0\":\"totalScore Encrypted total proficiency score\"}},\"evaluateSkillMatch(address,uint256)\":{\"details\":\"Returns encrypted skill level for HR to decrypt and evaluate\",\"params\":{\"candidate\":\"Candidate address\",\"skillIndex\":\"Index of the skill to evaluate (0-4)\"},\"returns\":{\"_0\":\"skillLevel Encrypted skill proficiency level\"}},\"getResumeInfo(address)\":{\"params\":{\"user\":\"Address of the resume owner\"}},\"getSkillLevels(address)\":{\"params\":{\"user\":\"Address of the resume owner\"}},\"revokeHR(address)\":{\"params\":{\"hr\":\"HR address to revoke\"}},\"submitResume(string,string,string,string[],bytes32[],bytes)\":{\"params\":{\"education\":\"Education experience\",\"inputProof\":\"Zama input proof for encrypted skill levels\",\"name\":\"User's name (can be desensitized)\",\"skillLevelsExt\":\"Array of encrypted skill proficiency levels (max 5)\",\"skillNames\":\"Array of skill names (max 5)\",\"workExperience\":\"Work experience\"}},\"updateResume(string,string,string,string[],bytes32[],bytes)\":{\"params\":{\"education\":\"Updated education\",\"inputProof\":\"Zama input proof\",\"name\":\"Updated name\",\"skillLevelsExt\":\"Updated encrypted skill levels (max 5)\",\"skillNames\":\"Updated skill names (max 5)\",\"workExperience\":\"Updated work experience\"}}},\"title\":\"Secure Resume Storage Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"authorizeHR(address)\":{\"notice\":\"Authorize an HR address\"},\"calculateSkillScore(address,uint256[])\":{\"notice\":\"HR function: Calculate total skill score across multiple skills\"},\"evaluateSkillMatch(address,uint256)\":{\"notice\":\"HR function: Evaluate skill match for a specific skill\"},\"getResumeInfo(address)\":{\"notice\":\"Get resume basic info (plaintext data)\"},\"getSkillLevels(address)\":{\"notice\":\"Get encrypted skill levels for a user\"},\"getStats()\":{\"notice\":\"Get contract statistics\"},\"hasResume(address)\":{\"notice\":\"Check if user has submitted a resume\"},\"revokeHR(address)\":{\"notice\":\"Revoke HR authorization\"},\"submitResume(string,string,string,string[],bytes32[],bytes)\":{\"notice\":\"Submit a new resume with encrypted skill data\"},\"updateResume(string,string,string,string[],bytes32[],bytes)\":{\"notice\":\"Update existing resume\"}},\"notice\":\"Stores encrypted resume data with FHE-protected skill evaluation\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SecureResume.sol\":\"SecureResume\"},\"evmVersion\":\"cancun\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":800},\"remappings\":[]},\"sources\":{\"@fhevm/solidity/config/ZamaConfig.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {SepoliaZamaOracleAddress} from \\\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\\\";\\nimport {FHE} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\nimport {CoprocessorConfig} from \\\"@fhevm/solidity/lib/Impl.sol\\\";\\n\\n/**\\n * @title   ZamaConfig.\\n * @notice  This library returns the FHEVM config for different networks\\n *          with the contract addresses for (1) ACL, (2) CoprocessorAddress, (3) DecryptionOracleAddress, (4) KMSVerifier,\\n *          which are deployed & maintained by Zama. It also returns the address of the decryption oracle.\\n */\\nlibrary ZamaConfig {\\n    function getSepoliaProtocolId() internal pure returns (uint256) {\\n        /// @note Zama Ethereum Sepolia protocol id is '10000 + Zama Ethereum protocol id'\\n        return 10001;\\n    }\\n\\n    function getSepoliaConfig() internal pure returns (CoprocessorConfig memory) {\\n        return\\n            CoprocessorConfig({\\n                ACLAddress: 0x50157CFfD6bBFA2DECe204a89ec419c23ef5755D,\\n                CoprocessorAddress: 0xCD3ab3bd6bcc0c0bf3E27912a92043e817B1cf69,\\n                DecryptionOracleAddress: SepoliaZamaOracleAddress,\\n                KMSVerifierAddress: 0x1364cBBf2cDF5032C47d8226a6f6FBD2AFCDacAC\\n            });\\n    }\\n\\n    function getEthereumProtocolId() internal pure returns (uint256) {\\n        /// @note Zama Ethereum protocol id is '1'\\n        return 1;\\n    }\\n\\n    function getEthereumConfig() internal pure returns (CoprocessorConfig memory) {\\n        /// @note The addresses below are placeholders and should be replaced with actual addresses\\n        /// once deployed on the Ethereum mainnet.\\n        return\\n            CoprocessorConfig({\\n                ACLAddress: address(0),\\n                CoprocessorAddress: address(0),\\n                DecryptionOracleAddress: address(0),\\n                KMSVerifierAddress: address(0)\\n            });\\n    }\\n}\\n\\n/**\\n * @title   SepoliaConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Sepolia network (chainId = 11155111).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract SepoliaConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getSepoliaConfig());\\n    }\\n\\n    function protocolId() public pure returns (uint256) {\\n        return ZamaConfig.getSepoliaProtocolId();\\n    }\\n}\\n\\n/**\\n * @title   EthereumConfig.\\n * @dev     This contract can be inherited by a contract wishing to use the FHEVM contracts provided by Zama\\n *          on the Ethereum (mainnet) network (chainId = 1).\\n *          Other providers may offer similar contracts deployed at different addresses.\\n *          If you wish to use them, you should rely on the instructions from these providers.\\n */\\ncontract EthereumConfig {\\n    constructor() {\\n        FHE.setCoprocessor(ZamaConfig.getEthereumConfig());\\n    }\\n\\n    function protocolId() public pure returns (uint256) {\\n        return ZamaConfig.getEthereumProtocolId();\\n    }\\n}\\n\",\"keccak256\":\"0xd7f4d44082b8281f31769e961b468786cacce9a318df56aa9a0dd7d4fb47e2e7\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FHE.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport \\\"./Impl.sol\\\";\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\nimport \\\"encrypted-types/EncryptedTypes.sol\\\";\\n\\n/**\\n * @title IKMSVerifier\\n * @notice This interface contains the only function required from KMSVerifier.\\n */\\ninterface IKMSVerifier {\\n    function verifyDecryptionEIP712KMSSignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory decryptedResult,\\n        bytes memory decryptionProof\\n    ) external returns (bool);\\n}\\n\\n/**\\n * @title IDecryptionOracle\\n * @notice This interface contains the only function required from DecryptionOracle.\\n */\\ninterface IDecryptionOracle {\\n    function requestDecryption(\\n        uint256 requestID,\\n        bytes32[] calldata ctsHandles,\\n        bytes4 callbackSelector\\n    ) external payable;\\n}\\n\\n/**\\n * @title   FHE\\n * @notice  This library is the interaction point for all smart contract developers\\n *          that interact with the FHEVM protocol.\\n */\\nlibrary FHE {\\n    /// @notice Returned if some handles were already saved for corresponding ID.\\n    error HandlesAlreadySavedForRequestID();\\n\\n    /// @notice Returned if there was not handle found for the requested ID.\\n    error NoHandleFoundForRequestID();\\n\\n    /// @notice Returned if the returned KMS signatures are not valid.\\n    error InvalidKMSSignatures();\\n\\n    /// @notice This event is emitted when requested decryption has been fulfilled.\\n    event DecryptionFulfilled(uint256 indexed requestID);\\n\\n    /**\\n     * @notice                  Sets the coprocessor addresses.\\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\\n        Impl.setCoprocessor(coprocessorConfig);\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(ebool v) internal pure returns (bool) {\\n        return ebool.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint8 v) internal pure returns (bool) {\\n        return euint8.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint16 v) internal pure returns (bool) {\\n        return euint16.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint32 v) internal pure returns (bool) {\\n        return euint32.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint64 v) internal pure returns (bool) {\\n        return euint64.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint128 v) internal pure returns (bool) {\\n        return euint128.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(eaddress v) internal pure returns (bool) {\\n        return eaddress.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Returns true if the encrypted integer is initialized and false otherwise.\\n     */\\n    function isInitialized(euint256 v) internal pure returns (bool) {\\n        return euint256.unwrap(v) != 0;\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, ebool b) and returns the result.\\n     */\\n    function and(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, ebool b) and returns the result.\\n     */\\n    function or(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, ebool b) and returns the result.\\n     */\\n    function xor(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, ebool b) and returns the result.\\n     */\\n    function eq(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, ebool b) and returns the result.\\n     */\\n    function ne(ebool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), ebool.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(asEuint16(a)), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint8 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint8 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint8 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint8 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(asEuint32(a)), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint16 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint16 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint16 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint16 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint16 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(asEuint64(a)), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint32 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint32 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint32 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint32 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint16 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint32 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint64 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint64 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(asEuint128(a)), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint64 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint64 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint8 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint16 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint16 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint32 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint32 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint64 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint64 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function add(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function sub(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function mul(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function ge(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function gt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function le(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function lt(euint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function min(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, euint128 b)  and returns the result.\\n     */\\n    function max(euint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint128 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint128 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(asEuint256(a)), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, eaddress b) and returns the result.\\n     */\\n    function eq(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, eaddress b) and returns the result.\\n     */\\n    function ne(eaddress a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), eaddress.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint8 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint16 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint16 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint32 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint32 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint64 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint64 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint128 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint128 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function and(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function or(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function xor(euint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function eq(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, euint256 b)  and returns the result.\\n     */\\n    function ne(euint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), euint256.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(ebool a, bool b) and returns the result.\\n     */\\n    function and(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(bool a, ebool b) and returns the result.\\n     */\\n    function and(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.and(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(ebool a, bool b) and returns the result.\\n     */\\n    function or(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(bool a, ebool b) and returns the result.\\n     */\\n    function or(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.or(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(ebool a, bool b) and returns the result.\\n     */\\n    function xor(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(bool a, ebool b) and returns the result.\\n     */\\n    function xor(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.xor(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(ebool a, bool b) and returns the result.\\n     */\\n    function eq(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(bool a, ebool b) and returns the result.\\n     */\\n    function eq(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.eq(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(ebool a, bool b) and returns the result.\\n     */\\n    function ne(ebool a, bool b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(a), bytes32(uint256(b ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(bool a, ebool b) and returns the result.\\n     */\\n    function ne(bool a, ebool b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEbool(false);\\n        }\\n        return ebool.wrap(Impl.ne(ebool.unwrap(b), bytes32(uint256(a ? 1 : 0)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint8 a, uint8 b) and returns the result.\\n     */\\n    function add(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint8 a, euint8 b) and returns the result.\\n     */\\n    function add(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.add(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint8 a, uint8 b) and returns the result.\\n     */\\n    function sub(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint8 a, euint8 b) and returns the result.\\n     */\\n    function sub(uint8 a, euint8 b) internal returns (euint8) {\\n        euint8 aEnc = asEuint8(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.sub(euint8.unwrap(aEnc), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint8 a, uint8 b) and returns the result.\\n     */\\n    function mul(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint8 a, euint8 b) and returns the result.\\n     */\\n    function mul(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.mul(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint8 a, uint8 b) and returns the result.\\n     */\\n    function div(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.div(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint8 a, uint8 b) and returns the result.\\n     */\\n    function rem(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rem(euint8.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint8 a, uint8 b) and returns the result.\\n     */\\n    function and(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint8 a, euint8 b) and returns the result.\\n     */\\n    function and(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.and(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint8 a, uint8 b) and returns the result.\\n     */\\n    function or(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint8 a, euint8 b) and returns the result.\\n     */\\n    function or(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.or(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint8 a, uint8 b) and returns the result.\\n     */\\n    function xor(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint8 a, euint8 b) and returns the result.\\n     */\\n    function xor(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.xor(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint8 a, uint8 b) and returns the result.\\n     */\\n    function eq(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint8 a, euint8 b) and returns the result.\\n     */\\n    function eq(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ne(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ne(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint8 a, uint8 b) and returns the result.\\n     */\\n    function ge(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint8 a, euint8 b) and returns the result.\\n     */\\n    function ge(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function gt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function gt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint8 a, uint8 b) and returns the result.\\n     */\\n    function le(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.le(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint8 a, euint8 b) and returns the result.\\n     */\\n    function le(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint8 a, uint8 b) and returns the result.\\n     */\\n    function lt(euint8 a, uint8 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint8 a, euint8 b) and returns the result.\\n     */\\n    function lt(uint8 a, euint8 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint8 a, uint8 b) and returns the result.\\n     */\\n    function min(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint8 a, euint8 b) and returns the result.\\n     */\\n    function min(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.min(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint8 a, uint8 b) and returns the result.\\n     */\\n    function max(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint8 a, euint8 b) and returns the result.\\n     */\\n    function max(uint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.max(euint8.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint16 a, uint16 b) and returns the result.\\n     */\\n    function add(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint16 a, euint16 b) and returns the result.\\n     */\\n    function add(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.add(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint16 a, uint16 b) and returns the result.\\n     */\\n    function sub(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint16 a, euint16 b) and returns the result.\\n     */\\n    function sub(uint16 a, euint16 b) internal returns (euint16) {\\n        euint16 aEnc = asEuint16(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.sub(euint16.unwrap(aEnc), euint16.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint16 a, uint16 b) and returns the result.\\n     */\\n    function mul(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint16 a, euint16 b) and returns the result.\\n     */\\n    function mul(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.mul(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint16 a, uint16 b) and returns the result.\\n     */\\n    function div(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.div(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint16 a, uint16 b) and returns the result.\\n     */\\n    function rem(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rem(euint16.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint16 a, uint16 b) and returns the result.\\n     */\\n    function and(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint16 a, euint16 b) and returns the result.\\n     */\\n    function and(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.and(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint16 a, uint16 b) and returns the result.\\n     */\\n    function or(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint16 a, euint16 b) and returns the result.\\n     */\\n    function or(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.or(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint16 a, uint16 b) and returns the result.\\n     */\\n    function xor(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint16 a, euint16 b) and returns the result.\\n     */\\n    function xor(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.xor(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint16 a, uint16 b) and returns the result.\\n     */\\n    function eq(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint16 a, euint16 b) and returns the result.\\n     */\\n    function eq(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ne(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ne(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint16 a, uint16 b) and returns the result.\\n     */\\n    function ge(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint16 a, euint16 b) and returns the result.\\n     */\\n    function ge(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function gt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function gt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint16 a, uint16 b) and returns the result.\\n     */\\n    function le(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.le(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint16 a, euint16 b) and returns the result.\\n     */\\n    function le(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint16 a, uint16 b) and returns the result.\\n     */\\n    function lt(euint16 a, uint16 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint16 a, euint16 b) and returns the result.\\n     */\\n    function lt(uint16 a, euint16 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint16 a, uint16 b) and returns the result.\\n     */\\n    function min(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint16 a, euint16 b) and returns the result.\\n     */\\n    function min(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.min(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint16 a, uint16 b) and returns the result.\\n     */\\n    function max(euint16 a, uint16 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint16 a, euint16 b) and returns the result.\\n     */\\n    function max(uint16 a, euint16 b) internal returns (euint16) {\\n        if (!isInitialized(b)) {\\n            b = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.max(euint16.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint32 a, uint32 b) and returns the result.\\n     */\\n    function add(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint32 a, euint32 b) and returns the result.\\n     */\\n    function add(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.add(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint32 a, uint32 b) and returns the result.\\n     */\\n    function sub(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint32 a, euint32 b) and returns the result.\\n     */\\n    function sub(uint32 a, euint32 b) internal returns (euint32) {\\n        euint32 aEnc = asEuint32(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.sub(euint32.unwrap(aEnc), euint32.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint32 a, uint32 b) and returns the result.\\n     */\\n    function mul(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint32 a, euint32 b) and returns the result.\\n     */\\n    function mul(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.mul(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint32 a, uint32 b) and returns the result.\\n     */\\n    function div(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.div(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint32 a, uint32 b) and returns the result.\\n     */\\n    function rem(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rem(euint32.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint32 a, uint32 b) and returns the result.\\n     */\\n    function and(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint32 a, euint32 b) and returns the result.\\n     */\\n    function and(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.and(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint32 a, uint32 b) and returns the result.\\n     */\\n    function or(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint32 a, euint32 b) and returns the result.\\n     */\\n    function or(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.or(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint32 a, uint32 b) and returns the result.\\n     */\\n    function xor(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint32 a, euint32 b) and returns the result.\\n     */\\n    function xor(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.xor(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint32 a, uint32 b) and returns the result.\\n     */\\n    function eq(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint32 a, euint32 b) and returns the result.\\n     */\\n    function eq(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ne(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ne(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint32 a, uint32 b) and returns the result.\\n     */\\n    function ge(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint32 a, euint32 b) and returns the result.\\n     */\\n    function ge(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function gt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function gt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint32 a, uint32 b) and returns the result.\\n     */\\n    function le(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.le(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint32 a, euint32 b) and returns the result.\\n     */\\n    function le(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint32 a, uint32 b) and returns the result.\\n     */\\n    function lt(euint32 a, uint32 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint32 a, euint32 b) and returns the result.\\n     */\\n    function lt(uint32 a, euint32 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint32 a, uint32 b) and returns the result.\\n     */\\n    function min(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint32 a, euint32 b) and returns the result.\\n     */\\n    function min(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.min(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint32 a, uint32 b) and returns the result.\\n     */\\n    function max(euint32 a, uint32 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint32 a, euint32 b) and returns the result.\\n     */\\n    function max(uint32 a, euint32 b) internal returns (euint32) {\\n        if (!isInitialized(b)) {\\n            b = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.max(euint32.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint64 a, uint64 b) and returns the result.\\n     */\\n    function add(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint64 a, euint64 b) and returns the result.\\n     */\\n    function add(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.add(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint64 a, uint64 b) and returns the result.\\n     */\\n    function sub(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint64 a, euint64 b) and returns the result.\\n     */\\n    function sub(uint64 a, euint64 b) internal returns (euint64) {\\n        euint64 aEnc = asEuint64(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.sub(euint64.unwrap(aEnc), euint64.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint64 a, uint64 b) and returns the result.\\n     */\\n    function mul(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint64 a, euint64 b) and returns the result.\\n     */\\n    function mul(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.mul(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint64 a, uint64 b) and returns the result.\\n     */\\n    function div(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.div(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint64 a, uint64 b) and returns the result.\\n     */\\n    function rem(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rem(euint64.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint64 a, uint64 b) and returns the result.\\n     */\\n    function and(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint64 a, euint64 b) and returns the result.\\n     */\\n    function and(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.and(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint64 a, uint64 b) and returns the result.\\n     */\\n    function or(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint64 a, euint64 b) and returns the result.\\n     */\\n    function or(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.or(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint64 a, uint64 b) and returns the result.\\n     */\\n    function xor(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint64 a, euint64 b) and returns the result.\\n     */\\n    function xor(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.xor(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint64 a, uint64 b) and returns the result.\\n     */\\n    function eq(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint64 a, euint64 b) and returns the result.\\n     */\\n    function eq(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ne(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ne(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint64 a, uint64 b) and returns the result.\\n     */\\n    function ge(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint64 a, euint64 b) and returns the result.\\n     */\\n    function ge(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function gt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function gt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint64 a, uint64 b) and returns the result.\\n     */\\n    function le(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.le(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint64 a, euint64 b) and returns the result.\\n     */\\n    function le(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint64 a, uint64 b) and returns the result.\\n     */\\n    function lt(euint64 a, uint64 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint64 a, euint64 b) and returns the result.\\n     */\\n    function lt(uint64 a, euint64 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint64 a, uint64 b) and returns the result.\\n     */\\n    function min(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint64 a, euint64 b) and returns the result.\\n     */\\n    function min(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.min(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint64 a, uint64 b) and returns the result.\\n     */\\n    function max(euint64 a, uint64 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint64 a, euint64 b) and returns the result.\\n     */\\n    function max(uint64 a, euint64 b) internal returns (euint64) {\\n        if (!isInitialized(b)) {\\n            b = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.max(euint64.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(euint128 a, uint128 b) and returns the result.\\n     */\\n    function add(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates add(uint128 a, euint128 b) and returns the result.\\n     */\\n    function add(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.add(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(euint128 a, uint128 b) and returns the result.\\n     */\\n    function sub(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates sub(uint128 a, euint128 b) and returns the result.\\n     */\\n    function sub(uint128 a, euint128 b) internal returns (euint128) {\\n        euint128 aEnc = asEuint128(a);\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.sub(euint128.unwrap(aEnc), euint128.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(euint128 a, uint128 b) and returns the result.\\n     */\\n    function mul(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates mul(uint128 a, euint128 b) and returns the result.\\n     */\\n    function mul(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.mul(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates div(euint128 a, uint128 b) and returns the result.\\n     */\\n    function div(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.div(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates rem(euint128 a, uint128 b) and returns the result.\\n     */\\n    function rem(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rem(euint128.unwrap(a), bytes32(uint256(b))));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint128 a, uint128 b) and returns the result.\\n     */\\n    function and(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint128 a, euint128 b) and returns the result.\\n     */\\n    function and(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.and(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint128 a, uint128 b) and returns the result.\\n     */\\n    function or(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint128 a, euint128 b) and returns the result.\\n     */\\n    function or(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.or(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint128 a, uint128 b) and returns the result.\\n     */\\n    function xor(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint128 a, euint128 b) and returns the result.\\n     */\\n    function xor(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.xor(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint128 a, uint128 b) and returns the result.\\n     */\\n    function eq(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint128 a, euint128 b) and returns the result.\\n     */\\n    function eq(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ne(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ne(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(euint128 a, uint128 b) and returns the result.\\n     */\\n    function ge(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ge(uint128 a, euint128 b) and returns the result.\\n     */\\n    function ge(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function gt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates gt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function gt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(euint128 a, uint128 b) and returns the result.\\n     */\\n    function le(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.le(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates le(uint128 a, euint128 b) and returns the result.\\n     */\\n    function le(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.ge(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(euint128 a, uint128 b) and returns the result.\\n     */\\n    function lt(euint128 a, uint128 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.lt(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates lt(uint128 a, euint128 b) and returns the result.\\n     */\\n    function lt(uint128 a, euint128 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return ebool.wrap(Impl.gt(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(euint128 a, uint128 b) and returns the result.\\n     */\\n    function min(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates min(uint128 a, euint128 b) and returns the result.\\n     */\\n    function min(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.min(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(euint128 a, uint128 b) and returns the result.\\n     */\\n    function max(euint128 a, uint128 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates max(uint128 a, euint128 b) and returns the result.\\n     */\\n    function max(uint128 a, euint128 b) internal returns (euint128) {\\n        if (!isInitialized(b)) {\\n            b = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.max(euint128.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(eaddress a, address b) and returns the result.\\n     */\\n    function eq(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(address a, eaddress b) and returns the result.\\n     */\\n    function eq(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.eq(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(eaddress a, address b) and returns the result.\\n     */\\n    function ne(eaddress a, address b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(a), bytes32(uint256(uint160(b))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(address a, eaddress b) and returns the result.\\n     */\\n    function ne(address a, eaddress b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEaddress(address(0));\\n        }\\n        return ebool.wrap(Impl.ne(eaddress.unwrap(b), bytes32(uint256(uint160(a))), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(euint256 a, uint256 b) and returns the result.\\n     */\\n    function and(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates and(uint256 a, euint256 b) and returns the result.\\n     */\\n    function and(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.and(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(euint256 a, uint256 b) and returns the result.\\n     */\\n    function or(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates or(uint256 a, euint256 b) and returns the result.\\n     */\\n    function or(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.or(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(euint256 a, uint256 b) and returns the result.\\n     */\\n    function xor(euint256 a, uint256 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates xor(uint256 a, euint256 b) and returns the result.\\n     */\\n    function xor(uint256 a, euint256 b) internal returns (euint256) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.xor(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(euint256 a, uint256 b) and returns the result.\\n     */\\n    function eq(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates eq(uint256 a, euint256 b) and returns the result.\\n     */\\n    function eq(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.eq(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(euint256 a, uint256 b) and returns the result.\\n     */\\n    function ne(euint256 a, uint256 b) internal returns (ebool) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates ne(uint256 a, euint256 b) and returns the result.\\n     */\\n    function ne(uint256 a, euint256 b) internal returns (ebool) {\\n        if (!isInitialized(b)) {\\n            b = asEuint256(0);\\n        }\\n        return ebool.wrap(Impl.ne(euint256.unwrap(b), bytes32(uint256(a)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint8 a, uint8) and returns the result.\\n     */\\n    function shl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint8 a, uint8) and returns the result.\\n     */\\n    function shr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.shr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint8 a, uint8) and returns the result.\\n     */\\n    function rotl(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotl(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint8 a, euint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), euint8.unwrap(b), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint8 a, uint8) and returns the result.\\n     */\\n    function rotr(euint8 a, uint8 b) internal returns (euint8) {\\n        if (!isInitialized(a)) {\\n            a = asEuint8(0);\\n        }\\n        return euint8.wrap(Impl.rotr(euint8.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint16 a, uint8) and returns the result.\\n     */\\n    function shl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint16 a, uint8) and returns the result.\\n     */\\n    function shr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.shr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint16 a, uint8) and returns the result.\\n     */\\n    function rotl(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotl(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint16 a, euint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), euint16.unwrap(asEuint16(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint16 a, uint8) and returns the result.\\n     */\\n    function rotr(euint16 a, uint8 b) internal returns (euint16) {\\n        if (!isInitialized(a)) {\\n            a = asEuint16(0);\\n        }\\n        return euint16.wrap(Impl.rotr(euint16.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint32 a, uint8) and returns the result.\\n     */\\n    function shl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint32 a, uint8) and returns the result.\\n     */\\n    function shr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.shr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint32 a, uint8) and returns the result.\\n     */\\n    function rotl(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotl(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint32 a, euint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), euint32.unwrap(asEuint32(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint32 a, uint8) and returns the result.\\n     */\\n    function rotr(euint32 a, uint8 b) internal returns (euint32) {\\n        if (!isInitialized(a)) {\\n            a = asEuint32(0);\\n        }\\n        return euint32.wrap(Impl.rotr(euint32.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint64 a, uint8) and returns the result.\\n     */\\n    function shl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint64 a, uint8) and returns the result.\\n     */\\n    function shr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.shr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint64 a, uint8) and returns the result.\\n     */\\n    function rotl(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotl(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint64 a, euint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), euint64.unwrap(asEuint64(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint64 a, uint8) and returns the result.\\n     */\\n    function rotr(euint64 a, uint8 b) internal returns (euint64) {\\n        if (!isInitialized(a)) {\\n            a = asEuint64(0);\\n        }\\n        return euint64.wrap(Impl.rotr(euint64.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint128 a, uint8) and returns the result.\\n     */\\n    function shl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint128 a, uint8) and returns the result.\\n     */\\n    function shr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.shr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint128 a, uint8) and returns the result.\\n     */\\n    function rotl(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotl(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint128 a, euint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), euint128.unwrap(asEuint128(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint128 a, uint8) and returns the result.\\n     */\\n    function rotr(euint128 a, uint8 b) internal returns (euint128) {\\n        if (!isInitialized(a)) {\\n            a = asEuint128(0);\\n        }\\n        return euint128.wrap(Impl.rotr(euint128.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shl(euint256 a, uint8) and returns the result.\\n     */\\n    function shl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function shr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates shr(euint256 a, uint8) and returns the result.\\n     */\\n    function shr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.shr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotl(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotl(euint256 a, uint8) and returns the result.\\n     */\\n    function rotl(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotl(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, euint8 b) and returns the result.\\n     */\\n    function rotr(euint256 a, euint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        if (!isInitialized(b)) {\\n            b = asEuint8(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), euint256.unwrap(asEuint256(b)), false));\\n    }\\n\\n    /**\\n     * @dev Evaluates rotr(euint256 a, uint8) and returns the result.\\n     */\\n    function rotr(euint256 a, uint8 b) internal returns (euint256) {\\n        if (!isInitialized(a)) {\\n            a = asEuint256(0);\\n        }\\n        return euint256.wrap(Impl.rotr(euint256.unwrap(a), bytes32(uint256(b)), true));\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, ebool a, ebool b) internal returns (ebool) {\\n        return ebool.wrap(Impl.select(ebool.unwrap(control), ebool.unwrap(a), ebool.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint8 a, euint8 b) internal returns (euint8) {\\n        return euint8.wrap(Impl.select(ebool.unwrap(control), euint8.unwrap(a), euint8.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint16 a, euint16 b) internal returns (euint16) {\\n        return euint16.wrap(Impl.select(ebool.unwrap(control), euint16.unwrap(a), euint16.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint32 a, euint32 b) internal returns (euint32) {\\n        return euint32.wrap(Impl.select(ebool.unwrap(control), euint32.unwrap(a), euint32.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint64 a, euint64 b) internal returns (euint64) {\\n        return euint64.wrap(Impl.select(ebool.unwrap(control), euint64.unwrap(a), euint64.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint128 a, euint128 b) internal returns (euint128) {\\n        return euint128.wrap(Impl.select(ebool.unwrap(control), euint128.unwrap(a), euint128.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, eaddress a, eaddress b) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.select(ebool.unwrap(control), eaddress.unwrap(a), eaddress.unwrap(b)));\\n    }\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(ebool control, euint256 a, euint256 b) internal returns (euint256) {\\n        return euint256.wrap(Impl.select(ebool.unwrap(control), euint256.unwrap(a), euint256.unwrap(b)));\\n    }\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint8'.\\n     */\\n    function asEuint8(euint16 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint8'.\\n     */\\n    function asEuint8(euint32 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint8'.\\n     */\\n    function asEuint8(euint64 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint8'.\\n     */\\n    function asEuint8(euint128 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint8'.\\n     */\\n    function asEuint8(euint256 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint8));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint8'.\\n     */\\n    function asEuint8(ebool b) internal returns (euint8) {\\n        return euint8.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'ebool'.\\n     */\\n    function asEbool(euint8 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint16'.\\n     */\\n    function asEuint16(euint8 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint16'.\\n     */\\n    function asEuint16(euint32 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint16'.\\n     */\\n    function asEuint16(euint64 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint16'.\\n     */\\n    function asEuint16(euint128 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint16'.\\n     */\\n    function asEuint16(euint256 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint16));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint16'.\\n     */\\n    function asEuint16(ebool b) internal returns (euint16) {\\n        return euint16.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'ebool'.\\n     */\\n    function asEbool(euint16 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint32'.\\n     */\\n    function asEuint32(euint8 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint32'.\\n     */\\n    function asEuint32(euint16 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint32'.\\n     */\\n    function asEuint32(euint64 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint32'.\\n     */\\n    function asEuint32(euint128 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint32'.\\n     */\\n    function asEuint32(euint256 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint32));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint32'.\\n     */\\n    function asEuint32(ebool b) internal returns (euint32) {\\n        return euint32.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'ebool'.\\n     */\\n    function asEbool(euint32 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint64'.\\n     */\\n    function asEuint64(euint8 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint64'.\\n     */\\n    function asEuint64(euint16 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint64'.\\n     */\\n    function asEuint64(euint32 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint64'.\\n     */\\n    function asEuint64(euint128 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint64'.\\n     */\\n    function asEuint64(euint256 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint64));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint64'.\\n     */\\n    function asEuint64(ebool b) internal returns (euint64) {\\n        return euint64.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'ebool'.\\n     */\\n    function asEbool(euint64 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint128'.\\n     */\\n    function asEuint128(euint8 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint128'.\\n     */\\n    function asEuint128(euint16 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint128'.\\n     */\\n    function asEuint128(euint32 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint128'.\\n     */\\n    function asEuint128(euint64 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'euint128'.\\n     */\\n    function asEuint128(euint256 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(euint256.unwrap(value), FheType.Uint128));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint128'.\\n     */\\n    function asEuint128(ebool b) internal returns (euint128) {\\n        return euint128.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'ebool'.\\n     */\\n    function asEbool(euint128 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint8' to 'euint256'.\\n     */\\n    function asEuint256(euint8 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint8.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint16' to 'euint256'.\\n     */\\n    function asEuint256(euint16 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint16.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint32' to 'euint256'.\\n     */\\n    function asEuint256(euint32 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint32.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint64' to 'euint256'.\\n     */\\n    function asEuint256(euint64 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint64.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint128' to 'euint256'.\\n     */\\n    function asEuint256(euint128 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(euint128.unwrap(value), FheType.Uint256));\\n    }\\n\\n    /**\\n    /** \\n     * @dev Converts an 'ebool' to an 'euint256'.\\n     */\\n    function asEuint256(ebool b) internal returns (euint256) {\\n        return euint256.wrap(Impl.cast(ebool.unwrap(b), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Casts an encrypted integer from 'euint256' to 'ebool'.\\n     */\\n    function asEbool(euint256 value) internal returns (ebool) {\\n        return ne(value, 0);\\n    }\\n\\n    /**\\n     * @dev Evaluates not(ebool value) and returns the result.\\n     */\\n    function not(ebool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.not(ebool.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint8 value) and returns the result.\\n     */\\n    function neg(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.neg(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint8 value) and returns the result.\\n     */\\n    function not(euint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.not(euint8.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint16 value) and returns the result.\\n     */\\n    function neg(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.neg(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint16 value) and returns the result.\\n     */\\n    function not(euint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.not(euint16.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint32 value) and returns the result.\\n     */\\n    function neg(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.neg(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint32 value) and returns the result.\\n     */\\n    function not(euint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.not(euint32.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint64 value) and returns the result.\\n     */\\n    function neg(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.neg(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint64 value) and returns the result.\\n     */\\n    function not(euint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.not(euint64.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint128 value) and returns the result.\\n     */\\n    function neg(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.neg(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint128 value) and returns the result.\\n     */\\n    function not(euint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.not(euint128.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates neg(euint256 value) and returns the result.\\n     */\\n    function neg(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.neg(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Evaluates not(euint256 value) and returns the result.\\n     */\\n    function not(euint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.not(euint256.unwrap(value)));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted ebool integer.\\n     */\\n    function fromExternal(externalEbool inputHandle, bytes memory inputProof) internal returns (ebool) {\\n        return ebool.wrap(Impl.verify(externalEbool.unwrap(inputHandle), inputProof, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Converts a plaintext boolean to an encrypted boolean.\\n     */\\n    function asEbool(bool value) internal returns (ebool) {\\n        return ebool.wrap(Impl.trivialEncrypt(value ? 1 : 0, FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint8 integer.\\n     */\\n    function fromExternal(externalEuint8 inputHandle, bytes memory inputProof) internal returns (euint8) {\\n        return euint8.wrap(Impl.verify(externalEuint8.unwrap(inputHandle), inputProof, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint8 integer.\\n     */\\n    function asEuint8(uint8 value) internal returns (euint8) {\\n        return euint8.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint16 integer.\\n     */\\n    function fromExternal(externalEuint16 inputHandle, bytes memory inputProof) internal returns (euint16) {\\n        return euint16.wrap(Impl.verify(externalEuint16.unwrap(inputHandle), inputProof, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint16 integer.\\n     */\\n    function asEuint16(uint16 value) internal returns (euint16) {\\n        return euint16.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint32 integer.\\n     */\\n    function fromExternal(externalEuint32 inputHandle, bytes memory inputProof) internal returns (euint32) {\\n        return euint32.wrap(Impl.verify(externalEuint32.unwrap(inputHandle), inputProof, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint32 integer.\\n     */\\n    function asEuint32(uint32 value) internal returns (euint32) {\\n        return euint32.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint64 integer.\\n     */\\n    function fromExternal(externalEuint64 inputHandle, bytes memory inputProof) internal returns (euint64) {\\n        return euint64.wrap(Impl.verify(externalEuint64.unwrap(inputHandle), inputProof, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint64 integer.\\n     */\\n    function asEuint64(uint64 value) internal returns (euint64) {\\n        return euint64.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint128 integer.\\n     */\\n    function fromExternal(externalEuint128 inputHandle, bytes memory inputProof) internal returns (euint128) {\\n        return euint128.wrap(Impl.verify(externalEuint128.unwrap(inputHandle), inputProof, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint128 integer.\\n     */\\n    function asEuint128(uint128 value) internal returns (euint128) {\\n        return euint128.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted eaddress integer.\\n     */\\n    function fromExternal(externalEaddress inputHandle, bytes memory inputProof) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.verify(externalEaddress.unwrap(inputHandle), inputProof, FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted eaddress integer.\\n     */\\n    function asEaddress(address value) internal returns (eaddress) {\\n        return eaddress.wrap(Impl.trivialEncrypt(uint256(uint160(value)), FheType.Uint160));\\n    }\\n\\n    /**\\n     * @dev Convert an inputHandle with corresponding inputProof to an encrypted euint256 integer.\\n     */\\n    function fromExternal(externalEuint256 inputHandle, bytes memory inputProof) internal returns (euint256) {\\n        return euint256.wrap(Impl.verify(externalEuint256.unwrap(inputHandle), inputProof, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Convert a plaintext value to an encrypted euint256 integer.\\n     */\\n    function asEuint256(uint256 value) internal returns (euint256) {\\n        return euint256.wrap(Impl.trivialEncrypt(uint256(value), FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEbool() internal returns (ebool) {\\n        return ebool.wrap(Impl.rand(FheType.Bool));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint8() internal returns (euint8) {\\n        return euint8.wrap(Impl.rand(FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 8-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint8(uint8 upperBound) internal returns (euint8) {\\n        return euint8.wrap(Impl.randBounded(upperBound, FheType.Uint8));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint16() internal returns (euint16) {\\n        return euint16.wrap(Impl.rand(FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 16-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint16(uint16 upperBound) internal returns (euint16) {\\n        return euint16.wrap(Impl.randBounded(upperBound, FheType.Uint16));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint32() internal returns (euint32) {\\n        return euint32.wrap(Impl.rand(FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 32-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint32(uint32 upperBound) internal returns (euint32) {\\n        return euint32.wrap(Impl.randBounded(upperBound, FheType.Uint32));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint64() internal returns (euint64) {\\n        return euint64.wrap(Impl.rand(FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 64-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint64(uint64 upperBound) internal returns (euint64) {\\n        return euint64.wrap(Impl.randBounded(upperBound, FheType.Uint64));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint128() internal returns (euint128) {\\n        return euint128.wrap(Impl.rand(FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 128-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint128(uint128 upperBound) internal returns (euint128) {\\n        return euint128.wrap(Impl.randBounded(upperBound, FheType.Uint128));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted value.\\n     */\\n    function randEuint256() internal returns (euint256) {\\n        return euint256.wrap(Impl.rand(FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev Generates a random encrypted 256-bit unsigned integer in the [0, upperBound) range.\\n     *      The upperBound must be a power of 2.\\n     */\\n    function randEuint256(uint256 upperBound) internal returns (euint256) {\\n        return euint256.wrap(Impl.randBounded(upperBound, FheType.Uint256));\\n    }\\n\\n    /**\\n     * @dev This function cleans the transient storage for the ACL (accounts) and the InputVerifier\\n     *      (input proofs).\\n     *      This could be useful for integration with Account Abstraction when bundling several\\n     *      UserOps calling the FHEVMExecutor.\\n     */\\n    function cleanTransientStorage() internal {\\n        Impl.cleanTransientStorageACL();\\n        Impl.cleanTransientStorageInputVerifier();\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(ebool value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(ebool value) internal view returns (bool) {\\n        return Impl.isAllowed(ebool.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(ebool value, address account) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(ebool value) internal returns (ebool) {\\n        Impl.allow(ebool.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(ebool value, address account) internal returns (ebool) {\\n        Impl.allowTransient(ebool.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(ebool value) internal returns (ebool) {\\n        Impl.makePubliclyDecryptable(ebool.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(ebool value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(ebool.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint8 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint8 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint8.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint8 value, address account) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint8 value) internal returns (euint8) {\\n        Impl.allow(euint8.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint8 value, address account) internal returns (euint8) {\\n        Impl.allowTransient(euint8.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint8 value) internal returns (euint8) {\\n        Impl.makePubliclyDecryptable(euint8.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint8 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint8.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint16 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint16 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint16.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint16 value, address account) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint16 value) internal returns (euint16) {\\n        Impl.allow(euint16.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint16 value, address account) internal returns (euint16) {\\n        Impl.allowTransient(euint16.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint16 value) internal returns (euint16) {\\n        Impl.makePubliclyDecryptable(euint16.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint16 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint16.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint32 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint32 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint32.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint32 value, address account) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint32 value) internal returns (euint32) {\\n        Impl.allow(euint32.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint32 value, address account) internal returns (euint32) {\\n        Impl.allowTransient(euint32.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint32 value) internal returns (euint32) {\\n        Impl.makePubliclyDecryptable(euint32.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint32 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint32.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint64 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint64 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint64.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint64 value, address account) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint64 value) internal returns (euint64) {\\n        Impl.allow(euint64.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint64 value, address account) internal returns (euint64) {\\n        Impl.allowTransient(euint64.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint64 value) internal returns (euint64) {\\n        Impl.makePubliclyDecryptable(euint64.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint64 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint64.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint128 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint128 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint128.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint128 value, address account) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint128 value) internal returns (euint128) {\\n        Impl.allow(euint128.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint128 value, address account) internal returns (euint128) {\\n        Impl.allowTransient(euint128.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint128 value) internal returns (euint128) {\\n        Impl.makePubliclyDecryptable(euint128.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint128 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint128.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(eaddress value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(eaddress value) internal view returns (bool) {\\n        return Impl.isAllowed(eaddress.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(eaddress value) internal returns (eaddress) {\\n        Impl.allow(eaddress.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(eaddress value, address account) internal returns (eaddress) {\\n        Impl.allowTransient(eaddress.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(eaddress value) internal returns (eaddress) {\\n        Impl.makePubliclyDecryptable(eaddress.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(eaddress value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(eaddress.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Returns whether the account is allowed to use the value.\\n     */\\n    function isAllowed(euint256 value, address account) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), account);\\n    }\\n\\n    /**\\n     * @dev Returns whether the sender is allowed to use the value.\\n     */\\n    function isSenderAllowed(euint256 value) internal view returns (bool) {\\n        return Impl.isAllowed(euint256.unwrap(value), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for the address account.\\n     */\\n    function allow(euint256 value, address account) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value for this address (address(this)).\\n     */\\n    function allowThis(euint256 value) internal returns (euint256) {\\n        Impl.allow(euint256.unwrap(value), address(this));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Allows the use of value by address account for this transaction.\\n     */\\n    function allowTransient(euint256 value, address account) internal returns (euint256) {\\n        Impl.allowTransient(euint256.unwrap(value), account);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Makes the value publicly decryptable.\\n     */\\n    function makePubliclyDecryptable(euint256 value) internal returns (euint256) {\\n        Impl.makePubliclyDecryptable(euint256.unwrap(value));\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns whether the the value is publicly decryptable.\\n     */\\n    function isPubliclyDecryptable(euint256 value) internal view returns (bool) {\\n        return Impl.isPubliclyDecryptable(euint256.unwrap(value));\\n    }\\n\\n    /**\\n     * @dev Recovers the stored array of handles corresponding to requestID.\\n     */\\n    function loadRequestedHandles(uint256 requestID) internal view returns (bytes32[] memory) {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length == 0) {\\n            revert NoHandleFoundForRequestID();\\n        }\\n        return $.requestedHandles[requestID];\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector\\n    ) internal returns (uint256 requestID) {\\n        requestID = requestDecryption(ctsHandles, callbackSelector, 0);\\n    }\\n\\n    /**\\n     * @dev     Calls the DecryptionOracle contract to request the decryption of a list of handles, with a custom msgValue.\\n     * @notice  Also does the needed call to ACL::allowForDecryption with requested handles.\\n     */\\n    function requestDecryption(\\n        bytes32[] memory ctsHandles,\\n        bytes4 callbackSelector,\\n        uint256 msgValue\\n    ) internal returns (uint256 requestID) {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        requestID = $.counterRequest;\\n        CoprocessorConfig storage $$ = Impl.getCoprocessorConfig();\\n        IACL($$.ACLAddress).allowForDecryption(ctsHandles);\\n        IDecryptionOracle($$.DecryptionOracleAddress).requestDecryption{value: msgValue}(\\n            requestID,\\n            ctsHandles,\\n            callbackSelector\\n        );\\n        saveRequestedHandles(requestID, ctsHandles);\\n        $.counterRequest++;\\n    }\\n\\n    /**\\n     * @dev     MUST be called inside the callback function the dApp contract to verify the signatures,\\n     * @dev     otherwise fake decryption results could be submitted.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     */\\n    function checkSignatures(uint256 requestID, bytes memory cleartexts, bytes memory decryptionProof) internal {\\n        bytes32[] memory handlesList = loadRequestedHandles(requestID);\\n        bool isVerified = verifySignatures(handlesList, cleartexts, decryptionProof);\\n        if (!isVerified) {\\n            revert InvalidKMSSignatures();\\n        }\\n        emit DecryptionFulfilled(requestID);\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to link in storage an array of handles to its associated requestID.\\n     */\\n    function saveRequestedHandles(uint256 requestID, bytes32[] memory handlesList) private {\\n        DecryptionRequests storage $ = Impl.getDecryptionRequests();\\n        if ($.requestedHandles[requestID].length != 0) {\\n            revert HandlesAlreadySavedForRequestID();\\n        }\\n        $.requestedHandles[requestID] = handlesList;\\n    }\\n\\n    /**\\n     * @dev Private low-level function used to extract the decryptedResult bytes array and verify the KMS signatures.\\n     * @notice  Warning: MUST be called directly in the callback function called by the relayer.\\n     * @dev The callback function has the following signature:\\n     * - requestID (static uint256)\\n     * - cleartexts (dynamic bytes)\\n     * - decryptionProof (dynamic bytes)\\n     *\\n     * This means that the calldata is encoded in the following way:\\n     * - 4 bytes: selector\\n     * - 32 bytes: requestID\\n     * - 32 bytes: offset of the cleartexts\\n     * - 32 bytes: offset of the decryptionProof\\n     * - 32 bytes: length of the cleartexts (total number of bytes)\\n     * - n*32 bytes: the \\\"n\\\" cleartext values, with \\\"n\\\" the number of handles\\n     * - 32 bytes: length of the decryptionProof (total number of bytes)\\n     * - ... the data of the decryptionProof (signatures, extra data)\\n     */\\n    function verifySignatures(\\n        bytes32[] memory handlesList,\\n        bytes memory cleartexts,\\n        bytes memory decryptionProof\\n    ) private returns (bool) {\\n        // Compute the signature offset\\n        // This offset is computed by considering the format encoded by the KMS when creating the\\n        // \\\"decryptedResult\\\" bytes array (see comment below), which is the following:\\n        // - requestID: 32 bytes\\n        // - all \\\"n\\\" decrypted values (which is \\\"cleartexts\\\" itself): n*32 bytes (\\\"cleartexts.length\\\" bytes)\\n        // - offset of the signatures: 32 bytes\\n        // - the rest of signature values (lengths, offsets, values)\\n        // This means the expected offset to concatenate to the \\\"decryptedResult\\\" bytes array has\\n        // the following value: 32 + n*32 + 32\\n        // See https://docs.soliditylang.org/en/latest/abi-spec.html#use-of-dynamic-types for more details.\\n        // The signature offset will most likely be removed in the future,\\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\\n        uint256 signaturesOffset = 32 + cleartexts.length + 32;\\n\\n        // Built the \\\"decryptedResult\\\" bytes array\\n        // Currently, the \\\"decryptedResult\\\" is encoded (by the KMS) in the following format:\\n        // - n*32 bytes: the \\\"n\\\" decrypted values, \\\"cleartexts\\\" itself\\n        // - 32 bytes: offset of the signatures, as explained above\\n        // This is equivalent to concatenating the cleartexts and the signatures offset, which can\\n        // be done using abi.encoded in a gas efficient way.\\n        // The signature offset will most likely be removed in the future,\\n        // see https://github.com/zama-ai/fhevm-internal/issues/345\\n        // Here we can use \\\"encodePacked\\\" instead of \\\"abi.encode\\\" to save gas, as the cleartexts\\n        // and the signaturesOffset are already 32 bytes aligned (ie, no padding needed).\\n        bytes memory decryptedResult = abi.encodePacked(cleartexts, signaturesOffset);\\n\\n        CoprocessorConfig storage $ = Impl.getCoprocessorConfig();\\n        return\\n            IKMSVerifier($.KMSVerifierAddress).verifyDecryptionEIP712KMSSignatures(\\n                handlesList,\\n                decryptedResult,\\n                decryptionProof\\n            );\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(ebool value) internal pure returns (bytes32 ct) {\\n        ct = ebool.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint8 value) internal pure returns (bytes32 ct) {\\n        ct = euint8.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint16 value) internal pure returns (bytes32 ct) {\\n        ct = euint16.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint32 value) internal pure returns (bytes32 ct) {\\n        ct = euint32.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint64 value) internal pure returns (bytes32 ct) {\\n        ct = euint64.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint128 value) internal pure returns (bytes32 ct) {\\n        ct = euint128.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(eaddress value) internal pure returns (bytes32 ct) {\\n        ct = eaddress.unwrap(value);\\n    }\\n\\n    /**\\n     * @dev Converts handle from its custom type to the underlying bytes32. Used when requesting a decryption.\\n     */\\n    function toBytes32(euint256 value) internal pure returns (bytes32 ct) {\\n        ct = euint256.unwrap(value);\\n    }\\n}\\n\",\"keccak256\":\"0x7a7b1c85bbef1ad02125f11af2f1c009ab6549075ab8d51d31ae9352f0441f35\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/FheType.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nenum FheType {\\n    Bool,\\n    Uint4,\\n    Uint8,\\n    Uint16,\\n    Uint32,\\n    Uint64,\\n    Uint128,\\n    Uint160,\\n    Uint256,\\n    Uint512,\\n    Uint1024,\\n    Uint2048,\\n    Uint2,\\n    Uint6,\\n    Uint10,\\n    Uint12,\\n    Uint14,\\n    Int2,\\n    Int4,\\n    Int6,\\n    Int8,\\n    Int10,\\n    Int12,\\n    Int14,\\n    Int16,\\n    Int32,\\n    Int64,\\n    Int128,\\n    Int160,\\n    Int256,\\n    AsciiString,\\n    Int512,\\n    Int1024,\\n    Int2048,\\n    Uint24,\\n    Uint40,\\n    Uint48,\\n    Uint56,\\n    Uint72,\\n    Uint80,\\n    Uint88,\\n    Uint96,\\n    Uint104,\\n    Uint112,\\n    Uint120,\\n    Uint136,\\n    Uint144,\\n    Uint152,\\n    Uint168,\\n    Uint176,\\n    Uint184,\\n    Uint192,\\n    Uint200,\\n    Uint208,\\n    Uint216,\\n    Uint224,\\n    Uint232,\\n    Uint240,\\n    Uint248,\\n    Int24,\\n    Int40,\\n    Int48,\\n    Int56,\\n    Int72,\\n    Int80,\\n    Int88,\\n    Int96,\\n    Int104,\\n    Int112,\\n    Int120,\\n    Int136,\\n    Int144,\\n    Int152,\\n    Int168,\\n    Int176,\\n    Int184,\\n    Int192,\\n    Int200,\\n    Int208,\\n    Int216,\\n    Int224,\\n    Int232,\\n    Int240,\\n    Int248\\n}\\n\",\"keccak256\":\"0x945f006108fab92cb082a6e5a80525953f17b8d8dcf88a283a83fc80c765497a\",\"license\":\"BSD-3-Clause-Clear\"},\"@fhevm/solidity/lib/Impl.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\npragma solidity ^0.8.24;\\n\\nimport {FheType} from \\\"./FheType.sol\\\";\\n\\n/**\\n * @title   CoprocessorConfig\\n * @notice  This struct contains all addresses of core contracts, which are needed in a typical dApp.\\n */\\nstruct CoprocessorConfig {\\n    address ACLAddress;\\n    address CoprocessorAddress;\\n    address DecryptionOracleAddress;\\n    address KMSVerifierAddress;\\n}\\n\\n/**\\n * @title   DecryptionRequests\\n * @notice  This struct contains the internal counter for requestIDs generated by the dapp,\\n *          and the mapping from internal requestIDs to list of handles requested for decryption.\\n */\\nstruct DecryptionRequests {\\n    uint256 counterRequest;\\n    mapping(uint256 => bytes32[]) requestedHandles;\\n}\\n\\n/**\\n * @title   IFHEVMExecutor\\n * @notice  This interface contains all functions to conduct FHE operations.\\n */\\ninterface IFHEVMExecutor {\\n    /**\\n     * @notice              Computes fheAdd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheAdd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheSub operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheSub(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMul operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMul(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheDiv operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheDiv(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRem operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRem(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitAnd operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitAnd(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitOr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitOr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheBitXor operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheBitXor(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheShr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheShr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotl operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotl(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheRotr operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheRotr(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheEq operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheEq(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheNe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheGt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheGt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLe operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLe(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheLt operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheLt(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMin operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMin(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheMax operation.\\n     * @param lhs           LHS.\\n     * @param rhs           RHS.\\n     * @param scalarByte    Scalar byte.\\n     * @return result       Result.\\n     */\\n    function fheMax(bytes32 lhs, bytes32 rhs, bytes1 scalarByte) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNeg operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNeg(bytes32 ct) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes fheNot operation.\\n     * @param ct            Ct\\n     * @return result       Result.\\n     */\\n    function fheNot(bytes32 ct) external returns (bytes32 result);\\n    /**\\n     * @notice                Verifies the ciphertext.\\n     * @param inputHandle     Input handle.\\n     * @param callerAddress   Address of the caller.\\n     * @param inputProof      Input proof.\\n     * @param inputType       Input type.\\n     * @return result         Result.\\n     */\\n    function verifyCiphertext(\\n        bytes32 inputHandle,\\n        address callerAddress,\\n        bytes memory inputProof,\\n        FheType inputType\\n    ) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Performs the casting to a target type.\\n     * @param ct        Value to cast.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function cast(bytes32 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param ct        Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 ct, FheType toType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHEIfThenElse operation.\\n     * @param control       Control value.\\n     * @param ifTrue        If true.\\n     * @param ifFalse       If false.\\n     * @return result       Result.\\n     */\\n    function fheIfThenElse(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERand operation.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRand(FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice              Computes FHERandBounded operation.\\n     * @param upperBound    Upper bound value.\\n     * @param randType      Type for the random result.\\n     * @return result       Result.\\n     */\\n    function fheRandBounded(uint256 upperBound, FheType randType) external returns (bytes32 result);\\n\\n    /**\\n     * @notice                      Returns the address of the InputVerifier contract used by the coprocessor.\\n     * @return inputVerifierAddress Address of the InputVerifier.\\n     */\\n    function getInputVerifierAddress() external view returns (address);\\n}\\n\\n/**\\n * @title   IACL.\\n * @notice  This interface contains all functions that are used to conduct operations\\n *          with the ACL contract.\\n */\\ninterface IACL {\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param ciphertext    Ciphertext.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 ciphertext, address account) external;\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) external;\\n\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) external view returns (bool);\\n\\n    /**\\n     * @notice              Allows a list of handles to be decrypted.\\n     * @param handlesList   List of handles.\\n     */\\n    function allowForDecryption(bytes32[] memory handlesList) external;\\n\\n    /**\\n     * @notice                  Returns wether a handle is allowed to be publicly decrypted.\\n     * @param handle            Handle.\\n     * @return isDecryptable    Whether the handle can be publicly decrypted.\\n     */\\n    function isAllowedForDecryption(bytes32 handle) external view returns (bool);\\n}\\n\\n/**\\n * @title IInputVerifier\\n * @notice This interface contains the only function required from InputVerifier.\\n */\\ninterface IInputVerifier {\\n    /**\\n     * @dev This function removes the transient allowances, which could be useful for integration with\\n     *      Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorage() external;\\n}\\n\\n/**\\n * @title   Impl\\n * @notice  This library is the core implementation for computing FHE operations (e.g. add, sub, xor).\\n */\\nlibrary Impl {\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"confidential.storage.config\\\")) - 1)) & ~bytes32(uint256(0xff))\\n    bytes32 private constant CoprocessorConfigLocation =\\n        0x9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700;\\n\\n    /// keccak256(abi.encode(uint256(keccak256(\\\"confidential.storage.decryptionRequests\\\")) - 1)) & ~bytes32(uint256(0xff));\\n    bytes32 private constant DecryptionRequestsStorageLocation =\\n        0x878245876662ba28a480c5ea71726db859fb50222b0a3d7cbbc21cfa336faf00;\\n\\n    /**\\n     * @dev Returns the Coprocessor config.\\n     */\\n    function getCoprocessorConfig() internal pure returns (CoprocessorConfig storage $) {\\n        assembly {\\n            $.slot := CoprocessorConfigLocation\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the DecryptionRequests storage struct.\\n     */\\n    function getDecryptionRequests() internal pure returns (DecryptionRequests storage $) {\\n        assembly {\\n            $.slot := DecryptionRequestsStorageLocation\\n        }\\n    }\\n\\n    /**\\n     * @notice                  Sets the coprocessor addresses.\\n     * @param coprocessorConfig Coprocessor config struct that contains contract addresses.\\n     */\\n    function setCoprocessor(CoprocessorConfig memory coprocessorConfig) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        $.ACLAddress = coprocessorConfig.ACLAddress;\\n        $.CoprocessorAddress = coprocessorConfig.CoprocessorAddress;\\n        $.DecryptionOracleAddress = coprocessorConfig.DecryptionOracleAddress;\\n        $.KMSVerifierAddress = coprocessorConfig.KMSVerifierAddress;\\n    }\\n\\n    function add(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheAdd(lhs, rhs, scalarByte);\\n    }\\n\\n    function sub(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheSub(lhs, rhs, scalarByte);\\n    }\\n\\n    function mul(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMul(lhs, rhs, scalarByte);\\n    }\\n\\n    function div(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheDiv(lhs, rhs, scalarByte);\\n    }\\n\\n    function rem(bytes32 lhs, bytes32 rhs) internal returns (bytes32 result) {\\n        bytes1 scalarByte = 0x01;\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRem(lhs, rhs, scalarByte);\\n    }\\n\\n    function and(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitAnd(lhs, rhs, scalarByte);\\n    }\\n\\n    function or(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitOr(lhs, rhs, scalarByte);\\n    }\\n\\n    function xor(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheBitXor(lhs, rhs, scalarByte);\\n    }\\n\\n    function shl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShl(lhs, rhs, scalarByte);\\n    }\\n\\n    function shr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheShr(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotl(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotl(lhs, rhs, scalarByte);\\n    }\\n\\n    function rotr(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRotr(lhs, rhs, scalarByte);\\n    }\\n\\n    function eq(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheEq(lhs, rhs, scalarByte);\\n    }\\n\\n    function ne(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNe(lhs, rhs, scalarByte);\\n    }\\n\\n    function ge(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGe(lhs, rhs, scalarByte);\\n    }\\n\\n    function gt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheGt(lhs, rhs, scalarByte);\\n    }\\n\\n    function le(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLe(lhs, rhs, scalarByte);\\n    }\\n\\n    function lt(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheLt(lhs, rhs, scalarByte);\\n    }\\n\\n    function min(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMin(lhs, rhs, scalarByte);\\n    }\\n\\n    function max(bytes32 lhs, bytes32 rhs, bool scalar) internal returns (bytes32 result) {\\n        bytes1 scalarByte;\\n        if (scalar) {\\n            scalarByte = 0x01;\\n        } else {\\n            scalarByte = 0x00;\\n        }\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheMax(lhs, rhs, scalarByte);\\n    }\\n\\n    function neg(bytes32 ct) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNeg(ct);\\n    }\\n\\n    function not(bytes32 ct) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheNot(ct);\\n    }\\n\\n    /**\\n     * @dev If 'control's value is 'true', the result has the same value as 'ifTrue'.\\n     *      If 'control's value is 'false', the result has the same value as 'ifFalse'.\\n     */\\n    function select(bytes32 control, bytes32 ifTrue, bytes32 ifFalse) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheIfThenElse(control, ifTrue, ifFalse);\\n    }\\n\\n    /**\\n     * @notice              Verifies the ciphertext (FHEVMExecutor) and allows transient (ACL).\\n     * @param inputHandle   Input handle.\\n     * @param inputProof    Input proof.\\n     * @param toType        Input type.\\n     * @return result       Result.\\n     */\\n    function verify(bytes32 inputHandle, bytes memory inputProof, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).verifyCiphertext(inputHandle, msg.sender, inputProof, toType);\\n        IACL($.ACLAddress).allowTransient(result, msg.sender);\\n    }\\n\\n    /**\\n     * @notice            Performs the casting to a target type.\\n     * @param ciphertext  Ciphertext to cast.\\n     * @param toType      Target type.\\n     * @return result     Result value of the target type.\\n     */\\n    function cast(bytes32 ciphertext, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).cast(ciphertext, toType);\\n    }\\n\\n    /**\\n     * @notice          Does trivial encryption.\\n     * @param value     Value to encrypt.\\n     * @param toType    Target type.\\n     * @return result   Result value of the target type.\\n     */\\n    function trivialEncrypt(uint256 value, FheType toType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).trivialEncrypt(value, toType);\\n    }\\n\\n    function rand(FheType randType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRand(randType);\\n    }\\n\\n    function randBounded(uint256 upperBound, FheType randType) internal returns (bytes32 result) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        result = IFHEVMExecutor($.CoprocessorAddress).fheRandBounded(upperBound, randType);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle by address account for this transaction.\\n     * @dev                 The caller must be allowed to use handle for allowTransient() to succeed.\\n     *                      If not, allowTransient() reverts.\\n     *                      The Coprocessor contract can always allowTransient(), contrarily to allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allowTransient(bytes32 handle, address account) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).allowTransient(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the use of handle for the address account.\\n     * @dev                 The caller must be allowed to use handle for allow() to succeed. If not, allow() reverts.\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     */\\n    function allow(bytes32 handle, address account) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).allow(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Allows the handle to be publicly decryptable.\\n     * @dev                 The caller must be allowed to use handle for makePubliclyDecryptable() to succeed.\\n     *                      If not, makePubliclyDecryptable() reverts.\\n     * @param handle        Handle.\\n     */\\n    function makePubliclyDecryptable(bytes32 handle) internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        bytes32[] memory handleArray = new bytes32[](1);\\n        handleArray[0] = handle;\\n        IACL($.ACLAddress).allowForDecryption(handleArray);\\n    }\\n\\n    /**\\n     * @dev This function removes the transient allowances in the ACL, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageACL() internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        IACL($.ACLAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @dev This function removes the transient proofs in the InputVerifier, which could be useful for integration\\n     *      with Account Abstraction when bundling several UserOps calling the FHEVMExecutor Coprocessor.\\n     */\\n    function cleanTransientStorageInputVerifier() internal {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        address inputVerifierAddress = IFHEVMExecutor($.CoprocessorAddress).getInputVerifierAddress();\\n        IInputVerifier(inputVerifierAddress).cleanTransientStorage();\\n    }\\n\\n    /**\\n     * @notice              Returns whether the account is allowed to use the handle, either due to\\n     *                      allowTransient() or allow().\\n     * @param handle        Handle.\\n     * @param account       Address of the account.\\n     * @return isAllowed    Whether the account can access the handle.\\n     */\\n    function isAllowed(bytes32 handle, address account) internal view returns (bool) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        return IACL($.ACLAddress).isAllowed(handle, account);\\n    }\\n\\n    /**\\n     * @notice              Returns whether the handle is allowed to be publicly decrypted.\\n     * @param handle        Handle.\\n     * @return isAllowed    Whether the handle can be publicly decrypted.\\n     */\\n    function isPubliclyDecryptable(bytes32 handle) internal view returns (bool) {\\n        CoprocessorConfig storage $ = getCoprocessorConfig();\\n        return IACL($.ACLAddress).isAllowedForDecryption(handle);\\n    }\\n}\\n\",\"keccak256\":\"0xac25fa2fb870877e0079d8a08e064fcc2b87ff7ce956e11c9a920fc70d82859c\",\"license\":\"BSD-3-Clause-Clear\"},\"@zama-fhe/oracle-solidity/address/ZamaOracleAddress.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause-Clear\\n\\npragma solidity ^0.8.24;\\n\\naddress constant SepoliaZamaOracleAddress = 0xa02Cda4Ca3a71D7C46997716F4283aa851C28812;\\n\",\"keccak256\":\"0x1e1117254b0e777ecbb902f3b9bb7d0b10920b7896e5eaa62b5163046685b28b\",\"license\":\"BSD-3-Clause-Clear\"},\"contracts/SecureResume.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.24;\\r\\n\\r\\nimport {FHE, euint32, externalEuint32} from \\\"@fhevm/solidity/lib/FHE.sol\\\";\\r\\nimport {SepoliaConfig} from \\\"@fhevm/solidity/config/ZamaConfig.sol\\\";\\r\\n\\r\\n/// @title Secure Resume Storage Contract\\r\\n/// @notice Stores encrypted resume data with FHE-protected skill evaluation\\r\\n/// @dev Uses FHEVM to enable encrypted skill matching without decryption\\r\\ncontract SecureResume is SepoliaConfig {\\r\\n    struct Resume {\\r\\n        string name;                    // Can be desensitized (plaintext)\\r\\n        string education;               // Education experience (plaintext)\\r\\n        string workExperience;          // Work experience (plaintext)\\r\\n        euint32 skillLevel1;            // Encrypted skill proficiency levels (max 5 skills for MVP)\\r\\n        euint32 skillLevel2;\\r\\n        euint32 skillLevel3;\\r\\n        euint32 skillLevel4;\\r\\n        euint32 skillLevel5;\\r\\n        string skillName1;              // Skill names (plaintext)\\r\\n        string skillName2;\\r\\n        string skillName3;\\r\\n        string skillName4;\\r\\n        string skillName5;\\r\\n        uint8 skillCount;               // Number of skills stored\\r\\n        uint64 createdAt;\\r\\n        uint64 updatedAt;\\r\\n        bool exists;\\r\\n    }\\r\\n\\r\\n    // user => resume data\\r\\n    mapping(address => Resume) private _resumes;\\r\\n\\r\\n    // HR addresses with evaluation permissions\\r\\n    mapping(address => bool) public hrAddresses;\\r\\n\\r\\n    // Events\\r\\n    event ResumeSubmitted(address indexed user);\\r\\n    event ResumeUpdated(address indexed user);\\r\\n    event HRAuthorized(address indexed hr);\\r\\n    event HRRevoked(address indexed hr);\\r\\n\\r\\n    modifier onlyHR() {\\r\\n        require(hrAddresses[msg.sender], \\\"Not authorized HR\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Submit a new resume with encrypted skill data\\r\\n    /// @param name User's name (can be desensitized)\\r\\n    /// @param education Education experience\\r\\n    /// @param workExperience Work experience\\r\\n    /// @param skillNames Array of skill names (max 5)\\r\\n    /// @param skillLevelsExt Array of encrypted skill proficiency levels (max 5)\\r\\n    /// @param inputProof Zama input proof for encrypted skill levels\\r\\n    function submitResume(\\r\\n        string calldata name,\\r\\n        string calldata education,\\r\\n        string calldata workExperience,\\r\\n        string[] calldata skillNames,\\r\\n        externalEuint32[] calldata skillLevelsExt,\\r\\n        bytes calldata inputProof\\r\\n    ) external {\\r\\n        require(skillNames.length == skillLevelsExt.length, \\\"Skill arrays length mismatch\\\");\\r\\n        require(skillNames.length > 0 && skillNames.length <= 5, \\\"Must have 1-5 skills\\\");\\r\\n        require(bytes(name).length > 0, \\\"Name cannot be empty\\\");\\r\\n\\r\\n        Resume storage resume = _resumes[msg.sender];\\r\\n        resume.name = name;\\r\\n        resume.education = education;\\r\\n        resume.workExperience = workExperience;\\r\\n        resume.skillCount = uint8(skillNames.length);\\r\\n        resume.createdAt = uint64(block.timestamp);\\r\\n        resume.updatedAt = uint64(block.timestamp);\\r\\n        resume.exists = true;\\r\\n\\r\\n        // Store skills in fixed slots\\r\\n        for (uint256 i = 0; i < skillNames.length; i++) {\\r\\n            euint32 skillLevel = FHE.fromExternal(skillLevelsExt[i], inputProof);\\r\\n\\r\\n            if (i == 0) {\\r\\n                resume.skillLevel1 = skillLevel;\\r\\n                resume.skillName1 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel1);\\r\\n                FHE.allow(resume.skillLevel1, msg.sender);\\r\\n            } else if (i == 1) {\\r\\n                resume.skillLevel2 = skillLevel;\\r\\n                resume.skillName2 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel2);\\r\\n                FHE.allow(resume.skillLevel2, msg.sender);\\r\\n            } else if (i == 2) {\\r\\n                resume.skillLevel3 = skillLevel;\\r\\n                resume.skillName3 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel3);\\r\\n                FHE.allow(resume.skillLevel3, msg.sender);\\r\\n            } else if (i == 3) {\\r\\n                resume.skillLevel4 = skillLevel;\\r\\n                resume.skillName4 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel4);\\r\\n                FHE.allow(resume.skillLevel4, msg.sender);\\r\\n            } else if (i == 4) {\\r\\n                resume.skillLevel5 = skillLevel;\\r\\n                resume.skillName5 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel5);\\r\\n                FHE.allow(resume.skillLevel5, msg.sender);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit ResumeSubmitted(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @notice Update existing resume\\r\\n    /// @param name Updated name\\r\\n    /// @param education Updated education\\r\\n    /// @param workExperience Updated work experience\\r\\n    /// @param skillNames Updated skill names (max 5)\\r\\n    /// @param skillLevelsExt Updated encrypted skill levels (max 5)\\r\\n    /// @param inputProof Zama input proof\\r\\n    function updateResume(\\r\\n        string calldata name,\\r\\n        string calldata education,\\r\\n        string calldata workExperience,\\r\\n        string[] calldata skillNames,\\r\\n        externalEuint32[] calldata skillLevelsExt,\\r\\n        bytes calldata inputProof\\r\\n    ) external {\\r\\n        require(_resumes[msg.sender].exists, \\\"Resume does not exist\\\");\\r\\n        require(skillNames.length == skillLevelsExt.length, \\\"Skill arrays length mismatch\\\");\\r\\n        require(skillNames.length > 0 && skillNames.length <= 5, \\\"Must have 1-5 skills\\\");\\r\\n        require(bytes(name).length > 0, \\\"Name cannot be empty\\\");\\r\\n\\r\\n        Resume storage resume = _resumes[msg.sender];\\r\\n        resume.name = name;\\r\\n        resume.education = education;\\r\\n        resume.workExperience = workExperience;\\r\\n        resume.skillCount = uint8(skillNames.length);\\r\\n        resume.updatedAt = uint64(block.timestamp);\\r\\n\\r\\n        // Clear existing skills first\\r\\n        resume.skillName1 = \\\"\\\";\\r\\n        resume.skillName2 = \\\"\\\";\\r\\n        resume.skillName3 = \\\"\\\";\\r\\n        resume.skillName4 = \\\"\\\";\\r\\n        resume.skillName5 = \\\"\\\";\\r\\n\\r\\n        // Store updated skills in fixed slots\\r\\n        for (uint256 i = 0; i < skillNames.length; i++) {\\r\\n            euint32 skillLevel = FHE.fromExternal(skillLevelsExt[i], inputProof);\\r\\n\\r\\n            if (i == 0) {\\r\\n                resume.skillLevel1 = skillLevel;\\r\\n                resume.skillName1 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel1);\\r\\n                FHE.allow(resume.skillLevel1, msg.sender);\\r\\n            } else if (i == 1) {\\r\\n                resume.skillLevel2 = skillLevel;\\r\\n                resume.skillName2 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel2);\\r\\n                FHE.allow(resume.skillLevel2, msg.sender);\\r\\n            } else if (i == 2) {\\r\\n                resume.skillLevel3 = skillLevel;\\r\\n                resume.skillName3 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel3);\\r\\n                FHE.allow(resume.skillLevel3, msg.sender);\\r\\n            } else if (i == 3) {\\r\\n                resume.skillLevel4 = skillLevel;\\r\\n                resume.skillName4 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel4);\\r\\n                FHE.allow(resume.skillLevel4, msg.sender);\\r\\n            } else if (i == 4) {\\r\\n                resume.skillLevel5 = skillLevel;\\r\\n                resume.skillName5 = skillNames[i];\\r\\n                FHE.allowThis(resume.skillLevel5);\\r\\n                FHE.allow(resume.skillLevel5, msg.sender);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        emit ResumeUpdated(msg.sender);\\r\\n    }\\r\\n\\r\\n    /// @notice Get resume basic info (plaintext data)\\r\\n    /// @param user Address of the resume owner\\r\\n    function getResumeInfo(address user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory name,\\r\\n            string memory education,\\r\\n            string memory workExperience,\\r\\n            string[] memory skillNames,\\r\\n            uint64 createdAt,\\r\\n            uint64 updatedAt\\r\\n        )\\r\\n    {\\r\\n        require(_resumes[user].exists, \\\"Resume does not exist\\\");\\r\\n        Resume storage resume = _resumes[user];\\r\\n\\r\\n        // Build skill names array from fixed slots\\r\\n        string[] memory skillNamesArray = new string[](resume.skillCount);\\r\\n        if (resume.skillCount >= 1) skillNamesArray[0] = resume.skillName1;\\r\\n        if (resume.skillCount >= 2) skillNamesArray[1] = resume.skillName2;\\r\\n        if (resume.skillCount >= 3) skillNamesArray[2] = resume.skillName3;\\r\\n        if (resume.skillCount >= 4) skillNamesArray[3] = resume.skillName4;\\r\\n        if (resume.skillCount >= 5) skillNamesArray[4] = resume.skillName5;\\r\\n\\r\\n        return (\\r\\n            resume.name,\\r\\n            resume.education,\\r\\n            resume.workExperience,\\r\\n            skillNamesArray,\\r\\n            resume.createdAt,\\r\\n            resume.updatedAt\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /// @notice Get encrypted skill levels for a user\\r\\n    /// @param user Address of the resume owner\\r\\n    function getSkillLevels(address user) external view returns (euint32[] memory) {\\r\\n        require(_resumes[user].exists, \\\"Resume does not exist\\\");\\r\\n        Resume storage resume = _resumes[user];\\r\\n\\r\\n        // Build skill levels array from fixed slots\\r\\n        euint32[] memory skillLevelsArray = new euint32[](resume.skillCount);\\r\\n        if (resume.skillCount >= 1) skillLevelsArray[0] = resume.skillLevel1;\\r\\n        if (resume.skillCount >= 2) skillLevelsArray[1] = resume.skillLevel2;\\r\\n        if (resume.skillCount >= 3) skillLevelsArray[2] = resume.skillLevel3;\\r\\n        if (resume.skillCount >= 4) skillLevelsArray[3] = resume.skillLevel4;\\r\\n        if (resume.skillCount >= 5) skillLevelsArray[4] = resume.skillLevel5;\\r\\n\\r\\n        return skillLevelsArray;\\r\\n    }\\r\\n\\r\\n    /// @notice HR function: Evaluate skill match for a specific skill\\r\\n    /// @dev Returns encrypted skill level for HR to decrypt and evaluate\\r\\n    /// @param candidate Candidate address\\r\\n    /// @param skillIndex Index of the skill to evaluate (0-4)\\r\\n    /// @return skillLevel Encrypted skill proficiency level\\r\\n    function evaluateSkillMatch(\\r\\n        address candidate,\\r\\n        uint256 skillIndex\\r\\n    ) external onlyHR returns (euint32) {\\r\\n        require(_resumes[candidate].exists, \\\"Resume does not exist\\\");\\r\\n        require(skillIndex < _resumes[candidate].skillCount, \\\"Invalid skill index\\\");\\r\\n\\r\\n        Resume storage resume = _resumes[candidate];\\r\\n        euint32 skillLevel;\\r\\n\\r\\n        if (skillIndex == 0) skillLevel = resume.skillLevel1;\\r\\n        else if (skillIndex == 1) skillLevel = resume.skillLevel2;\\r\\n        else if (skillIndex == 2) skillLevel = resume.skillLevel3;\\r\\n        else if (skillIndex == 3) skillLevel = resume.skillLevel4;\\r\\n        else if (skillIndex == 4) skillLevel = resume.skillLevel5;\\r\\n        else revert(\\\"Invalid skill index\\\");\\r\\n\\r\\n        // Allow HR to access the result\\r\\n        FHE.allowThis(skillLevel);\\r\\n        FHE.allow(skillLevel, msg.sender);\\r\\n\\r\\n        return skillLevel;\\r\\n    }\\r\\n\\r\\n    /// @notice HR function: Calculate total skill score across multiple skills\\r\\n    /// @dev Performs encrypted addition without decrypting individual levels\\r\\n    /// @param candidate Candidate address\\r\\n    /// @param skillIndices Array of skill indices to include in score (0-4)\\r\\n    /// @return totalScore Encrypted total proficiency score\\r\\n    function calculateSkillScore(\\r\\n        address candidate,\\r\\n        uint256[] calldata skillIndices\\r\\n    ) external onlyHR returns (euint32) {\\r\\n        require(_resumes[candidate].exists, \\\"Resume does not exist\\\");\\r\\n\\r\\n        Resume storage resume = _resumes[candidate];\\r\\n        euint32 totalScore = FHE.asEuint32(0);\\r\\n\\r\\n        for (uint256 i = 0; i < skillIndices.length; i++) {\\r\\n            require(skillIndices[i] < resume.skillCount, \\\"Invalid skill index\\\");\\r\\n\\r\\n            euint32 skillLevel;\\r\\n            if (skillIndices[i] == 0) skillLevel = resume.skillLevel1;\\r\\n            else if (skillIndices[i] == 1) skillLevel = resume.skillLevel2;\\r\\n            else if (skillIndices[i] == 2) skillLevel = resume.skillLevel3;\\r\\n            else if (skillIndices[i] == 3) skillLevel = resume.skillLevel4;\\r\\n            else if (skillIndices[i] == 4) skillLevel = resume.skillLevel5;\\r\\n            else continue; // Skip invalid indices\\r\\n\\r\\n            totalScore = FHE.add(totalScore, skillLevel);\\r\\n        }\\r\\n\\r\\n        // Allow HR to access the result\\r\\n        FHE.allowThis(totalScore);\\r\\n        FHE.allow(totalScore, msg.sender);\\r\\n\\r\\n        return totalScore;\\r\\n    }\\r\\n\\r\\n    /// @notice Check if user has submitted a resume\\r\\n    function hasResume(address user) external view returns (bool) {\\r\\n        return _resumes[user].exists;\\r\\n    }\\r\\n\\r\\n    /// @notice Authorize an HR address\\r\\n    /// @param hr HR address to authorize\\r\\n    function authorizeHR(address hr) external {\\r\\n        // For MVP, allow any user to authorize HR (in production, this should be restricted)\\r\\n        hrAddresses[hr] = true;\\r\\n        emit HRAuthorized(hr);\\r\\n    }\\r\\n\\r\\n    /// @notice Revoke HR authorization\\r\\n    /// @param hr HR address to revoke\\r\\n    function revokeHR(address hr) external {\\r\\n        hrAddresses[hr] = false;\\r\\n        emit HRRevoked(hr);\\r\\n    }\\r\\n\\r\\n    /// @notice Get contract statistics\\r\\n    function getStats() external view returns (uint256 totalResumes) {\\r\\n        // This is a simplified implementation\\r\\n        // In a real contract, you might track total resumes differently\\r\\n        return 0; // Placeholder\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x065935560fdde3ac9cf659e1106a06e10c25b50a0e3ea782b7f4a1ac9135a1a5\",\"license\":\"MIT\"},\"encrypted-types/EncryptedTypes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\ntype ebool is bytes32;\\n\\ntype euint8 is bytes32;\\ntype euint16 is bytes32;\\ntype euint24 is bytes32;\\ntype euint32 is bytes32;\\ntype euint40 is bytes32;\\ntype euint48 is bytes32;\\ntype euint56 is bytes32;\\ntype euint64 is bytes32;\\ntype euint72 is bytes32;\\ntype euint80 is bytes32;\\ntype euint88 is bytes32;\\ntype euint96 is bytes32;\\ntype euint104 is bytes32;\\ntype euint112 is bytes32;\\ntype euint120 is bytes32;\\ntype euint128 is bytes32;\\ntype euint136 is bytes32;\\ntype euint144 is bytes32;\\ntype euint152 is bytes32;\\ntype euint160 is bytes32;\\ntype euint168 is bytes32;\\ntype euint176 is bytes32;\\ntype euint184 is bytes32;\\ntype euint192 is bytes32;\\ntype euint200 is bytes32;\\ntype euint208 is bytes32;\\ntype euint216 is bytes32;\\ntype euint224 is bytes32;\\ntype euint232 is bytes32;\\ntype euint240 is bytes32;\\ntype euint248 is bytes32;\\ntype euint256 is bytes32;\\n\\ntype eint8 is bytes32;\\ntype eint16 is bytes32;\\ntype eint24 is bytes32;\\ntype eint32 is bytes32;\\ntype eint40 is bytes32;\\ntype eint48 is bytes32;\\ntype eint56 is bytes32;\\ntype eint64 is bytes32;\\ntype eint72 is bytes32;\\ntype eint80 is bytes32;\\ntype eint88 is bytes32;\\ntype eint96 is bytes32;\\ntype eint104 is bytes32;\\ntype eint112 is bytes32;\\ntype eint120 is bytes32;\\ntype eint128 is bytes32;\\ntype eint136 is bytes32;\\ntype eint144 is bytes32;\\ntype eint152 is bytes32;\\ntype eint160 is bytes32;\\ntype eint168 is bytes32;\\ntype eint176 is bytes32;\\ntype eint184 is bytes32;\\ntype eint192 is bytes32;\\ntype eint200 is bytes32;\\ntype eint208 is bytes32;\\ntype eint216 is bytes32;\\ntype eint224 is bytes32;\\ntype eint232 is bytes32;\\ntype eint240 is bytes32;\\ntype eint248 is bytes32;\\ntype eint256 is bytes32;\\n\\ntype eaddress is bytes32;\\n\\ntype ebytes1 is bytes32;\\ntype ebytes2 is bytes32;\\ntype ebytes3 is bytes32;\\ntype ebytes4 is bytes32;\\ntype ebytes5 is bytes32;\\ntype ebytes6 is bytes32;\\ntype ebytes7 is bytes32;\\ntype ebytes8 is bytes32;\\ntype ebytes9 is bytes32;\\ntype ebytes10 is bytes32;\\ntype ebytes11 is bytes32;\\ntype ebytes12 is bytes32;\\ntype ebytes13 is bytes32;\\ntype ebytes14 is bytes32;\\ntype ebytes15 is bytes32;\\ntype ebytes16 is bytes32;\\ntype ebytes17 is bytes32;\\ntype ebytes18 is bytes32;\\ntype ebytes19 is bytes32;\\ntype ebytes20 is bytes32;\\ntype ebytes21 is bytes32;\\ntype ebytes22 is bytes32;\\ntype ebytes23 is bytes32;\\ntype ebytes24 is bytes32;\\ntype ebytes25 is bytes32;\\ntype ebytes26 is bytes32;\\ntype ebytes27 is bytes32;\\ntype ebytes28 is bytes32;\\ntype ebytes29 is bytes32;\\ntype ebytes30 is bytes32;\\ntype ebytes31 is bytes32;\\ntype ebytes32 is bytes32;\\n\\ntype externalEbool is bytes32;\\n\\ntype externalEuint8 is bytes32;\\ntype externalEuint16 is bytes32;\\ntype externalEuint24 is bytes32;\\ntype externalEuint32 is bytes32;\\ntype externalEuint40 is bytes32;\\ntype externalEuint48 is bytes32;\\ntype externalEuint56 is bytes32;\\ntype externalEuint64 is bytes32;\\ntype externalEuint72 is bytes32;\\ntype externalEuint80 is bytes32;\\ntype externalEuint88 is bytes32;\\ntype externalEuint96 is bytes32;\\ntype externalEuint104 is bytes32;\\ntype externalEuint112 is bytes32;\\ntype externalEuint120 is bytes32;\\ntype externalEuint128 is bytes32;\\ntype externalEuint136 is bytes32;\\ntype externalEuint144 is bytes32;\\ntype externalEuint152 is bytes32;\\ntype externalEuint160 is bytes32;\\ntype externalEuint168 is bytes32;\\ntype externalEuint176 is bytes32;\\ntype externalEuint184 is bytes32;\\ntype externalEuint192 is bytes32;\\ntype externalEuint200 is bytes32;\\ntype externalEuint208 is bytes32;\\ntype externalEuint216 is bytes32;\\ntype externalEuint224 is bytes32;\\ntype externalEuint232 is bytes32;\\ntype externalEuint240 is bytes32;\\ntype externalEuint248 is bytes32;\\ntype externalEuint256 is bytes32;\\n\\ntype externalEint8 is bytes32;\\ntype externalEint16 is bytes32;\\ntype externalEint24 is bytes32;\\ntype externalEint32 is bytes32;\\ntype externalEint40 is bytes32;\\ntype externalEint48 is bytes32;\\ntype externalEint56 is bytes32;\\ntype externalEint64 is bytes32;\\ntype externalEint72 is bytes32;\\ntype externalEint80 is bytes32;\\ntype externalEint88 is bytes32;\\ntype externalEint96 is bytes32;\\ntype externalEint104 is bytes32;\\ntype externalEint112 is bytes32;\\ntype externalEint120 is bytes32;\\ntype externalEint128 is bytes32;\\ntype externalEint136 is bytes32;\\ntype externalEint144 is bytes32;\\ntype externalEint152 is bytes32;\\ntype externalEint160 is bytes32;\\ntype externalEint168 is bytes32;\\ntype externalEint176 is bytes32;\\ntype externalEint184 is bytes32;\\ntype externalEint192 is bytes32;\\ntype externalEint200 is bytes32;\\ntype externalEint208 is bytes32;\\ntype externalEint216 is bytes32;\\ntype externalEint224 is bytes32;\\ntype externalEint232 is bytes32;\\ntype externalEint240 is bytes32;\\ntype externalEint248 is bytes32;\\ntype externalEint256 is bytes32;\\n\\ntype externalEaddress is bytes32;\\n\\ntype externalEbytes1 is bytes32;\\ntype externalEbytes2 is bytes32;\\ntype externalEbytes3 is bytes32;\\ntype externalEbytes4 is bytes32;\\ntype externalEbytes5 is bytes32;\\ntype externalEbytes6 is bytes32;\\ntype externalEbytes7 is bytes32;\\ntype externalEbytes8 is bytes32;\\ntype externalEbytes9 is bytes32;\\ntype externalEbytes10 is bytes32;\\ntype externalEbytes11 is bytes32;\\ntype externalEbytes12 is bytes32;\\ntype externalEbytes13 is bytes32;\\ntype externalEbytes14 is bytes32;\\ntype externalEbytes15 is bytes32;\\ntype externalEbytes16 is bytes32;\\ntype externalEbytes17 is bytes32;\\ntype externalEbytes18 is bytes32;\\ntype externalEbytes19 is bytes32;\\ntype externalEbytes20 is bytes32;\\ntype externalEbytes21 is bytes32;\\ntype externalEbytes22 is bytes32;\\ntype externalEbytes23 is bytes32;\\ntype externalEbytes24 is bytes32;\\ntype externalEbytes25 is bytes32;\\ntype externalEbytes26 is bytes32;\\ntype externalEbytes27 is bytes32;\\ntype externalEbytes28 is bytes32;\\ntype externalEbytes29 is bytes32;\\ntype externalEbytes30 is bytes32;\\ntype externalEbytes31 is bytes32;\\ntype externalEbytes32 is bytes32;\\n\",\"keccak256\":\"0x5da9799cd5c30067ea946164722197151baee1f2579a76f01874d4fb25df02a3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561000f575f5ffd5b5061018a6100ae604080516080810182525f80825260208201819052918101829052606081019190915250604080516080810182527350157cffd6bbfa2dece204a89ec419c23ef5755d815273cd3ab3bd6bcc0c0bf3e27912a92043e817b1cf69602082015273a02cda4ca3a71d7c46997716f4283aa851c2881291810191909152731364cbbf2cdf5032c47d8226a6f6fbd2afcdacac606082015290565b80517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970080546001600160a01b03199081166001600160a01b039384161790915560208301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497018054831691841691909117905560408301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497028054831691841691909117905560608301517f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497038054909216921691909117905550565b6122a9806101975f395ff3fe608060405234801561000f575f5ffd5b50600436106100cf575f3560e01c8063a4a06db21161007d578063d24a5e9a11610058578063d24a5e9a146101d8578063da1f12ab146101fd578063eb870b8214610205575f5ffd5b8063a4a06db21461019d578063a90cd594146101b0578063c59d4847146101d2575f5ffd5b80633764fcff116100ad5780633764fcff146101325780636d898b00146101455780636dba272514610158575f5ffd5b8063062b415d146100d3578063074252d1146100e8578063183329f314610111575b5f5ffd5b6100e66100e1366004611c96565b610218565b005b6100fb6100f6366004611de7565b61070f565b6040516101089190611e00565b60405180910390f35b61012461011f366004611e42565b6108f6565b604051908152602001610108565b6100e6610140366004611c96565b610b60565b6100e6610153366004611de7565b610f52565b61018d610166366004611de7565b6001600160a01b03165f908152602081905260409020600d0154600160881b900460ff1690565b6040519015158152602001610108565b6101246101ab366004611e91565b610fa0565b61018d6101be366004611de7565b60016020525f908152604090205460ff1681565b5f610124565b6101eb6101e6366004611de7565b61119a565b60405161010896959493929190611ee7565b612711610124565b6100e6610213366004611de7565b61180e565b335f908152602081905260409020600d0154600160881b900460ff1661027d5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b60448201526064015b60405180910390fd5b8483146102cc5760405162461bcd60e51b815260206004820152601c60248201527f536b696c6c20617272617973206c656e677468206d69736d61746368000000006044820152606401610274565b84158015906102dc575060058511155b6103285760405162461bcd60e51b815260206004820152601460248201527f4d757374206861766520312d3520736b696c6c730000000000000000000000006044820152606401610274565b8a6103755760405162461bcd60e51b815260206004820152601460248201527f4e616d652063616e6e6f7420626520656d7074790000000000000000000000006044820152606401610274565b335f9081526020819052604090208061038f8d8f83612046565b506001810161039f8b8d83612046565b50600281016103af898b83612046565b50600d8101805467ffffffffffffffff421669010000000000000000000270ffffffffffffffff0000000000000000ff1990911660ff89161717905560408051602081019091525f815260088201906104089082612100565b5060408051602081019091525f815260098201906104269082612100565b5060408051602081019091525f8152600a8201906104449082612100565b5060408051602081019091525f8152600b8201906104629082612100565b5060408051602081019091525f8152600c8201906104809082612100565b505f5b868110156106d5575f6104e38787848181106104a1576104a16121bb565b9050602002013586868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061185692505050565b9050815f0361054a5760038301819055888883818110610505576105056121bb565b905060200281019061051791906121cf565b6008850191610527919083612046565b506105358360030154611863565b50610544836003015433611872565b506106cc565b816001036105aa576004830181905588888381811061056b5761056b6121bb565b905060200281019061057d91906121cf565b600985019161058d919083612046565b5061059b8360040154611863565b50610544836004015433611872565b8160020361060a57600583018190558888838181106105cb576105cb6121bb565b90506020028101906105dd91906121cf565b600a8501916105ed919083612046565b506105fb8360050154611863565b50610544836005015433611872565b8160030361066a576006830181905588888381811061062b5761062b6121bb565b905060200281019061063d91906121cf565b600b85019161064d919083612046565b5061065b8360060154611863565b50610544836006015433611872565b816004036106cc576007830181905588888381811061068b5761068b6121bb565b905060200281019061069d91906121cf565b600c8501916106ad919083612046565b506106bb8360070154611863565b506106ca836007015433611872565b505b50600101610483565b5060405133907f2f553078529a300e0bdcc308c536a5568db4bea49762041dd34c279de778e7b4905f90a250505050505050505050505050565b6001600160a01b0381165f908152602081905260409020600d0154606090600160881b900460ff1661077b5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0382165f908152602081905260408120600d81015490919060ff1667ffffffffffffffff8111156107b5576107b5611fae565b6040519080825280602002602001820160405280156107de578160200160208202803683370190505b50600d830154909150600160ff90911610610817578160030154815f8151811061080a5761080a6121bb565b6020026020010181815250505b600d820154600260ff9091161061084d57816004015481600181518110610840576108406121bb565b6020026020010181815250505b600d820154600360ff9091161061088357816005015481600281518110610876576108766121bb565b6020026020010181815250505b600d820154600460ff909116106108b9578160060154816003815181106108ac576108ac6121bb565b6020026020010181815250505b600d820154600560ff909116106108ef578160070154816004815181106108e2576108e26121bb565b6020026020010181815250505b9392505050565b335f9081526001602052604081205460ff166109545760405162461bcd60e51b815260206004820152601160248201527f4e6f7420617574686f72697a65642048520000000000000000000000000000006044820152606401610274565b6001600160a01b0384165f908152602081905260409020600d0154600160881b900460ff166109bd5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0384165f908152602081905260408120906109de81611884565b90505f5b84811015610b4157600d83015460ff16868683818110610a0457610a046121bb565b9050602002013510610a4e5760405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b5f868683818110610a6157610a616121bb565b905060200201355f03610a7957506003830154610b2b565b868683818110610a8b57610a8b6121bb565b90506020020135600103610aa457506004830154610b2b565b868683818110610ab657610ab66121bb565b90506020020135600203610acf57506005830154610b2b565b868683818110610ae157610ae16121bb565b90506020020135600303610afa57506006830154610b2b565b868683818110610b0c57610b0c6121bb565b90506020020135600403610b2557506007830154610b2b565b50610b39565b610b35838261189c565b9250505b6001016109e2565b50610b4b81611863565b50610b568133611872565b5095945050505050565b848314610baf5760405162461bcd60e51b815260206004820152601c60248201527f536b696c6c20617272617973206c656e677468206d69736d61746368000000006044820152606401610274565b8415801590610bbf575060058511155b610c0b5760405162461bcd60e51b815260206004820152601460248201527f4d757374206861766520312d3520736b696c6c730000000000000000000000006044820152606401610274565b8a610c585760405162461bcd60e51b815260206004820152601460248201527f4e616d652063616e6e6f7420626520656d7074790000000000000000000000006044820152606401610274565b335f90815260208190526040902080610c728d8f83612046565b5060018101610c828b8d83612046565b5060028101610c92898b83612046565b50600d8101805471ff000000000000000000000000000000000019690100000000000000000067ffffffffffffffff42169081029190911671ffffffffffffffffff000000000000000000196101009290920268ffffffffffffffffff1990931660ff8b1617929092171617600160881b1790555f5b86811015610f18575f610d268787848181106104a1576104a16121bb565b9050815f03610d8d5760038301819055888883818110610d4857610d486121bb565b9050602002810190610d5a91906121cf565b6008850191610d6a919083612046565b50610d788360030154611863565b50610d87836003015433611872565b50610f0f565b81600103610ded5760048301819055888883818110610dae57610dae6121bb565b9050602002810190610dc091906121cf565b6009850191610dd0919083612046565b50610dde8360040154611863565b50610d87836004015433611872565b81600203610e4d5760058301819055888883818110610e0e57610e0e6121bb565b9050602002810190610e2091906121cf565b600a850191610e30919083612046565b50610e3e8360050154611863565b50610d87836005015433611872565b81600303610ead5760068301819055888883818110610e6e57610e6e6121bb565b9050602002810190610e8091906121cf565b600b850191610e90919083612046565b50610e9e8360060154611863565b50610d87836006015433611872565b81600403610f0f5760078301819055888883818110610ece57610ece6121bb565b9050602002810190610ee091906121cf565b600c850191610ef0919083612046565b50610efe8360070154611863565b50610f0d836007015433611872565b505b50600101610d08565b5060405133907f47366e32953474aab4e7614c7f4831cb4fe7e54b51b3e5c3ba0fdafa2af6a0e2905f90a250505050505050505050505050565b6001600160a01b0381165f818152600160208190526040808320805460ff1916909217909155517f3a870bf64864bca8e5c9b67d7bc058536151ae9ed4e30e455f2c785a5f0ad7e39190a250565b335f9081526001602052604081205460ff16610ffe5760405162461bcd60e51b815260206004820152601160248201527f4e6f7420617574686f72697a65642048520000000000000000000000000000006044820152606401610274565b6001600160a01b0383165f908152602081905260409020600d0154600160881b900460ff166110675760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0383165f908152602081905260409020600d015460ff1682106110c95760405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b6001600160a01b0383165f908152602081905260408120908381036110f35750600381015461117d565b836001036111065750600481015461117d565b836002036111195750600581015461117d565b8360030361112c5750600681015461117d565b8360040361113f5750600781015461117d565b60405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b61118681611863565b506111918133611872565b50949350505050565b6001600160a01b0381165f908152602081905260408120600d01546060918291829182918190600160881b900460ff1661120e5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0387165f908152602081905260408120600d81015490919060ff1667ffffffffffffffff81111561124857611248611fae565b60405190808252806020026020018201604052801561127b57816020015b60608152602001906001900390816112665790505b50600d830154909150600160ff909116106113395781600801805461129f90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546112cb90611fc2565b80156113165780601f106112ed57610100808354040283529160200191611316565b820191905f5260205f20905b8154815290600101906020018083116112f957829003601f168201915b5050505050815f8151811061132d5761132d6121bb565b60200260200101819052505b600d820154600260ff909116106113f45781600901805461135990611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461138590611fc2565b80156113d05780601f106113a7576101008083540402835291602001916113d0565b820191905f5260205f20905b8154815290600101906020018083116113b357829003601f168201915b5050505050816001815181106113e8576113e86121bb565b60200260200101819052505b600d820154600360ff909116106114af5781600a01805461141490611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461144090611fc2565b801561148b5780601f106114625761010080835404028352916020019161148b565b820191905f5260205f20905b81548152906001019060200180831161146e57829003601f168201915b5050505050816002815181106114a3576114a36121bb565b60200260200101819052505b600d820154600460ff9091161061156a5781600b0180546114cf90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546114fb90611fc2565b80156115465780601f1061151d57610100808354040283529160200191611546565b820191905f5260205f20905b81548152906001019060200180831161152957829003601f168201915b50505050508160038151811061155e5761155e6121bb565b60200260200101819052505b600d820154600560ff909116106116255781600c01805461158a90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546115b690611fc2565b80156116015780601f106115d857610100808354040283529160200191611601565b820191905f5260205f20905b8154815290600101906020018083116115e457829003601f168201915b505050505081600481518110611619576116196121bb565b60200260200101819052505b600d8201548254839160018301916002840191859167ffffffffffffffff6101008304811692690100000000000000000090041690869061166590611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461169190611fc2565b80156116dc5780601f106116b3576101008083540402835291602001916116dc565b820191905f5260205f20905b8154815290600101906020018083116116bf57829003601f168201915b505050505095508480546116ef90611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461171b90611fc2565b80156117665780601f1061173d57610100808354040283529160200191611766565b820191905f5260205f20905b81548152906001019060200180831161174957829003601f168201915b5050505050945083805461177990611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546117a590611fc2565b80156117f05780601f106117c7576101008083540402835291602001916117f0565b820191905f5260205f20905b8154815290600101906020018083116117d357829003601f168201915b50505050509350975097509750975097509750505091939550919395565b6001600160a01b0381165f81815260016020526040808220805460ff19169055517fc42b49eb3125a66d1757221ff561f492edb801dde6252972e1839545041fc4b69190a250565b5f6108ef838360046118ca565b5f61186e82306119ea565b5090565b5f61187d83836119ea565b5090919050565b5f6118968263ffffffff166004611a73565b92915050565b5f826118ae576118ab5f611884565b92505b816118bf576118bc5f611884565b91505b6108ef83835f611b30565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497015460405163196d0b9b60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b039091169063196d0b9b90611943908890339089908990600401612232565b6020604051808303815f875af115801561195f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119839190612271565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b1580156119cc575f5ffd5b505af11580156119de573d5f5f3e3d5ffd5b50505050509392505050565b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497008054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b158015611a58575f5ffd5b505af1158015611a6a573d5f5f3e3d5ffd5b50505050505050565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970154604051639cd07acb60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b0390911690639cd07acb90611ae89087908790600401612288565b6020604051808303815f875af1158015611b04573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b289190612271565b949350505050565b5f5f8215611b435750600160f81b611b46565b505f5b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700600181015460405163022f65e760e31b815260048101899052602481018890527fff00000000000000000000000000000000000000000000000000000000000000851660448201529192506001600160a01b03169063117b2f38906064016020604051808303815f875af1158015611be2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c069190612271565b9695505050505050565b5f5f83601f840112611c20575f5ffd5b50813567ffffffffffffffff811115611c37575f5ffd5b602083019150836020828501011115611c4e575f5ffd5b9250929050565b5f5f83601f840112611c65575f5ffd5b50813567ffffffffffffffff811115611c7c575f5ffd5b6020830191508360208260051b8501011115611c4e575f5ffd5b5f5f5f5f5f5f5f5f5f5f5f5f60c08d8f031215611cb1575f5ffd5b67ffffffffffffffff8d351115611cc6575f5ffd5b611cd38e8e358f01611c10565b909c509a5067ffffffffffffffff60208e01351115611cf0575f5ffd5b611d008e60208f01358f01611c10565b909a50985067ffffffffffffffff60408e01351115611d1d575f5ffd5b611d2d8e60408f01358f01611c10565b909850965067ffffffffffffffff60608e01351115611d4a575f5ffd5b611d5a8e60608f01358f01611c55565b909650945067ffffffffffffffff60808e01351115611d77575f5ffd5b611d878e60808f01358f01611c55565b909450925067ffffffffffffffff60a08e01351115611da4575f5ffd5b611db48e60a08f01358f01611c10565b81935080925050509295989b509295989b509295989b565b80356001600160a01b0381168114611de2575f5ffd5b919050565b5f60208284031215611df7575f5ffd5b6108ef82611dcc565b602080825282518282018190525f918401906040840190835b81811015611e37578351835260209384019390920191600101611e19565b509095945050505050565b5f5f5f60408486031215611e54575f5ffd5b611e5d84611dcc565b9250602084013567ffffffffffffffff811115611e78575f5ffd5b611e8486828701611c55565b9497909650939450505050565b5f5f60408385031215611ea2575f5ffd5b611eab83611dcc565b946020939093013593505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b60c081525f611ef960c0830189611eb9565b8281036020840152611f0b8189611eb9565b90508281036040840152611f1f8188611eb9565b9050828103606084015280865180835260208301915060208160051b840101602089015f5b83811015611f7657601f19868403018552611f60838351611eb9565b6020958601959093509190910190600101611f44565b505067ffffffffffffffff881660808701529350611f9392505050565b67ffffffffffffffff831660a0830152979650505050505050565b634e487b7160e01b5f52604160045260245ffd5b600181811c90821680611fd657607f821691505b602082108103611ff457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561204157805f5260205f20601f840160051c8101602085101561201f5750805b601f840160051c820191505b8181101561203e575f815560010161202b565b50505b505050565b67ffffffffffffffff83111561205e5761205e611fae565b6120728361206c8354611fc2565b83611ffa565b5f601f8411600181146120a3575f851561208c5750838201355b5f19600387901b1c1916600186901b17835561203e565b5f83815260208120601f198716915b828110156120d257868501358255602094850194600190920191016120b2565b50868210156120ee575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b815167ffffffffffffffff81111561211a5761211a611fae565b61212e816121288454611fc2565b84611ffa565b6020601f821160018114612160575f83156121495750848201515b5f19600385901b1c1916600184901b17845561203e565b5f84815260208120601f198516915b8281101561218f578785015182556020948501946001909201910161216f565b50848210156121ac57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b634e487b7160e01b5f52603260045260245ffd5b5f5f8335601e198436030181126121e4575f5ffd5b83018035915067ffffffffffffffff8211156121fe575f5ffd5b602001915036819003821315611c4e575f5ffd5b6054811061222e57634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f6122596080830185611eb9565b90506122686060830184612212565b95945050505050565b5f60208284031215612281575f5ffd5b5051919050565b828152604081016108ef602083018461221256fea164736f6c634300081b000a",
  "deployedBytecode": "0x608060405234801561000f575f5ffd5b50600436106100cf575f3560e01c8063a4a06db21161007d578063d24a5e9a11610058578063d24a5e9a146101d8578063da1f12ab146101fd578063eb870b8214610205575f5ffd5b8063a4a06db21461019d578063a90cd594146101b0578063c59d4847146101d2575f5ffd5b80633764fcff116100ad5780633764fcff146101325780636d898b00146101455780636dba272514610158575f5ffd5b8063062b415d146100d3578063074252d1146100e8578063183329f314610111575b5f5ffd5b6100e66100e1366004611c96565b610218565b005b6100fb6100f6366004611de7565b61070f565b6040516101089190611e00565b60405180910390f35b61012461011f366004611e42565b6108f6565b604051908152602001610108565b6100e6610140366004611c96565b610b60565b6100e6610153366004611de7565b610f52565b61018d610166366004611de7565b6001600160a01b03165f908152602081905260409020600d0154600160881b900460ff1690565b6040519015158152602001610108565b6101246101ab366004611e91565b610fa0565b61018d6101be366004611de7565b60016020525f908152604090205460ff1681565b5f610124565b6101eb6101e6366004611de7565b61119a565b60405161010896959493929190611ee7565b612711610124565b6100e6610213366004611de7565b61180e565b335f908152602081905260409020600d0154600160881b900460ff1661027d5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b60448201526064015b60405180910390fd5b8483146102cc5760405162461bcd60e51b815260206004820152601c60248201527f536b696c6c20617272617973206c656e677468206d69736d61746368000000006044820152606401610274565b84158015906102dc575060058511155b6103285760405162461bcd60e51b815260206004820152601460248201527f4d757374206861766520312d3520736b696c6c730000000000000000000000006044820152606401610274565b8a6103755760405162461bcd60e51b815260206004820152601460248201527f4e616d652063616e6e6f7420626520656d7074790000000000000000000000006044820152606401610274565b335f9081526020819052604090208061038f8d8f83612046565b506001810161039f8b8d83612046565b50600281016103af898b83612046565b50600d8101805467ffffffffffffffff421669010000000000000000000270ffffffffffffffff0000000000000000ff1990911660ff89161717905560408051602081019091525f815260088201906104089082612100565b5060408051602081019091525f815260098201906104269082612100565b5060408051602081019091525f8152600a8201906104449082612100565b5060408051602081019091525f8152600b8201906104629082612100565b5060408051602081019091525f8152600c8201906104809082612100565b505f5b868110156106d5575f6104e38787848181106104a1576104a16121bb565b9050602002013586868080601f0160208091040260200160405190810160405280939291908181526020018383808284375f9201919091525061185692505050565b9050815f0361054a5760038301819055888883818110610505576105056121bb565b905060200281019061051791906121cf565b6008850191610527919083612046565b506105358360030154611863565b50610544836003015433611872565b506106cc565b816001036105aa576004830181905588888381811061056b5761056b6121bb565b905060200281019061057d91906121cf565b600985019161058d919083612046565b5061059b8360040154611863565b50610544836004015433611872565b8160020361060a57600583018190558888838181106105cb576105cb6121bb565b90506020028101906105dd91906121cf565b600a8501916105ed919083612046565b506105fb8360050154611863565b50610544836005015433611872565b8160030361066a576006830181905588888381811061062b5761062b6121bb565b905060200281019061063d91906121cf565b600b85019161064d919083612046565b5061065b8360060154611863565b50610544836006015433611872565b816004036106cc576007830181905588888381811061068b5761068b6121bb565b905060200281019061069d91906121cf565b600c8501916106ad919083612046565b506106bb8360070154611863565b506106ca836007015433611872565b505b50600101610483565b5060405133907f2f553078529a300e0bdcc308c536a5568db4bea49762041dd34c279de778e7b4905f90a250505050505050505050505050565b6001600160a01b0381165f908152602081905260409020600d0154606090600160881b900460ff1661077b5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0382165f908152602081905260408120600d81015490919060ff1667ffffffffffffffff8111156107b5576107b5611fae565b6040519080825280602002602001820160405280156107de578160200160208202803683370190505b50600d830154909150600160ff90911610610817578160030154815f8151811061080a5761080a6121bb565b6020026020010181815250505b600d820154600260ff9091161061084d57816004015481600181518110610840576108406121bb565b6020026020010181815250505b600d820154600360ff9091161061088357816005015481600281518110610876576108766121bb565b6020026020010181815250505b600d820154600460ff909116106108b9578160060154816003815181106108ac576108ac6121bb565b6020026020010181815250505b600d820154600560ff909116106108ef578160070154816004815181106108e2576108e26121bb565b6020026020010181815250505b9392505050565b335f9081526001602052604081205460ff166109545760405162461bcd60e51b815260206004820152601160248201527f4e6f7420617574686f72697a65642048520000000000000000000000000000006044820152606401610274565b6001600160a01b0384165f908152602081905260409020600d0154600160881b900460ff166109bd5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0384165f908152602081905260408120906109de81611884565b90505f5b84811015610b4157600d83015460ff16868683818110610a0457610a046121bb565b9050602002013510610a4e5760405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b5f868683818110610a6157610a616121bb565b905060200201355f03610a7957506003830154610b2b565b868683818110610a8b57610a8b6121bb565b90506020020135600103610aa457506004830154610b2b565b868683818110610ab657610ab66121bb565b90506020020135600203610acf57506005830154610b2b565b868683818110610ae157610ae16121bb565b90506020020135600303610afa57506006830154610b2b565b868683818110610b0c57610b0c6121bb565b90506020020135600403610b2557506007830154610b2b565b50610b39565b610b35838261189c565b9250505b6001016109e2565b50610b4b81611863565b50610b568133611872565b5095945050505050565b848314610baf5760405162461bcd60e51b815260206004820152601c60248201527f536b696c6c20617272617973206c656e677468206d69736d61746368000000006044820152606401610274565b8415801590610bbf575060058511155b610c0b5760405162461bcd60e51b815260206004820152601460248201527f4d757374206861766520312d3520736b696c6c730000000000000000000000006044820152606401610274565b8a610c585760405162461bcd60e51b815260206004820152601460248201527f4e616d652063616e6e6f7420626520656d7074790000000000000000000000006044820152606401610274565b335f90815260208190526040902080610c728d8f83612046565b5060018101610c828b8d83612046565b5060028101610c92898b83612046565b50600d8101805471ff000000000000000000000000000000000019690100000000000000000067ffffffffffffffff42169081029190911671ffffffffffffffffff000000000000000000196101009290920268ffffffffffffffffff1990931660ff8b1617929092171617600160881b1790555f5b86811015610f18575f610d268787848181106104a1576104a16121bb565b9050815f03610d8d5760038301819055888883818110610d4857610d486121bb565b9050602002810190610d5a91906121cf565b6008850191610d6a919083612046565b50610d788360030154611863565b50610d87836003015433611872565b50610f0f565b81600103610ded5760048301819055888883818110610dae57610dae6121bb565b9050602002810190610dc091906121cf565b6009850191610dd0919083612046565b50610dde8360040154611863565b50610d87836004015433611872565b81600203610e4d5760058301819055888883818110610e0e57610e0e6121bb565b9050602002810190610e2091906121cf565b600a850191610e30919083612046565b50610e3e8360050154611863565b50610d87836005015433611872565b81600303610ead5760068301819055888883818110610e6e57610e6e6121bb565b9050602002810190610e8091906121cf565b600b850191610e90919083612046565b50610e9e8360060154611863565b50610d87836006015433611872565b81600403610f0f5760078301819055888883818110610ece57610ece6121bb565b9050602002810190610ee091906121cf565b600c850191610ef0919083612046565b50610efe8360070154611863565b50610f0d836007015433611872565b505b50600101610d08565b5060405133907f47366e32953474aab4e7614c7f4831cb4fe7e54b51b3e5c3ba0fdafa2af6a0e2905f90a250505050505050505050505050565b6001600160a01b0381165f818152600160208190526040808320805460ff1916909217909155517f3a870bf64864bca8e5c9b67d7bc058536151ae9ed4e30e455f2c785a5f0ad7e39190a250565b335f9081526001602052604081205460ff16610ffe5760405162461bcd60e51b815260206004820152601160248201527f4e6f7420617574686f72697a65642048520000000000000000000000000000006044820152606401610274565b6001600160a01b0383165f908152602081905260409020600d0154600160881b900460ff166110675760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0383165f908152602081905260409020600d015460ff1682106110c95760405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b6001600160a01b0383165f908152602081905260408120908381036110f35750600381015461117d565b836001036111065750600481015461117d565b836002036111195750600581015461117d565b8360030361112c5750600681015461117d565b8360040361113f5750600781015461117d565b60405162461bcd60e51b8152602060048201526013602482015272092dcecc2d8d2c840e6d6d2d8d840d2dcc8caf606b1b6044820152606401610274565b61118681611863565b506111918133611872565b50949350505050565b6001600160a01b0381165f908152602081905260408120600d01546060918291829182918190600160881b900460ff1661120e5760405162461bcd60e51b815260206004820152601560248201527414995cdd5b5948191bd95cc81b9bdd08195e1a5cdd605a1b6044820152606401610274565b6001600160a01b0387165f908152602081905260408120600d81015490919060ff1667ffffffffffffffff81111561124857611248611fae565b60405190808252806020026020018201604052801561127b57816020015b60608152602001906001900390816112665790505b50600d830154909150600160ff909116106113395781600801805461129f90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546112cb90611fc2565b80156113165780601f106112ed57610100808354040283529160200191611316565b820191905f5260205f20905b8154815290600101906020018083116112f957829003601f168201915b5050505050815f8151811061132d5761132d6121bb565b60200260200101819052505b600d820154600260ff909116106113f45781600901805461135990611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461138590611fc2565b80156113d05780601f106113a7576101008083540402835291602001916113d0565b820191905f5260205f20905b8154815290600101906020018083116113b357829003601f168201915b5050505050816001815181106113e8576113e86121bb565b60200260200101819052505b600d820154600360ff909116106114af5781600a01805461141490611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461144090611fc2565b801561148b5780601f106114625761010080835404028352916020019161148b565b820191905f5260205f20905b81548152906001019060200180831161146e57829003601f168201915b5050505050816002815181106114a3576114a36121bb565b60200260200101819052505b600d820154600460ff9091161061156a5781600b0180546114cf90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546114fb90611fc2565b80156115465780601f1061151d57610100808354040283529160200191611546565b820191905f5260205f20905b81548152906001019060200180831161152957829003601f168201915b50505050508160038151811061155e5761155e6121bb565b60200260200101819052505b600d820154600560ff909116106116255781600c01805461158a90611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546115b690611fc2565b80156116015780601f106115d857610100808354040283529160200191611601565b820191905f5260205f20905b8154815290600101906020018083116115e457829003601f168201915b505050505081600481518110611619576116196121bb565b60200260200101819052505b600d8201548254839160018301916002840191859167ffffffffffffffff6101008304811692690100000000000000000090041690869061166590611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461169190611fc2565b80156116dc5780601f106116b3576101008083540402835291602001916116dc565b820191905f5260205f20905b8154815290600101906020018083116116bf57829003601f168201915b505050505095508480546116ef90611fc2565b80601f016020809104026020016040519081016040528092919081815260200182805461171b90611fc2565b80156117665780601f1061173d57610100808354040283529160200191611766565b820191905f5260205f20905b81548152906001019060200180831161174957829003601f168201915b5050505050945083805461177990611fc2565b80601f01602080910402602001604051908101604052809291908181526020018280546117a590611fc2565b80156117f05780601f106117c7576101008083540402835291602001916117f0565b820191905f5260205f20905b8154815290600101906020018083116117d357829003601f168201915b50505050509350975097509750975097509750505091939550919395565b6001600160a01b0381165f81815260016020526040808220805460ff19169055517fc42b49eb3125a66d1757221ff561f492edb801dde6252972e1839545041fc4b69190a250565b5f6108ef838360046118ca565b5f61186e82306119ea565b5090565b5f61187d83836119ea565b5090919050565b5f6118968263ffffffff166004611a73565b92915050565b5f826118ae576118ab5f611884565b92505b816118bf576118bc5f611884565b91505b6108ef83835f611b30565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497015460405163196d0b9b60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b039091169063196d0b9b90611943908890339089908990600401612232565b6020604051808303815f875af115801561195f573d5f5f3e3d5ffd5b505050506040513d601f19601f820116820180604052508101906119839190612271565b8154604051630f8e573b60e21b8152600481018390523360248201529193506001600160a01b031690633e395cec906044015f604051808303815f87803b1580156119cc575f5ffd5b505af11580156119de573d5f5f3e3d5ffd5b50505050509392505050565b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e46497008054604051635ca4b5b160e11b8152600481018690526001600160a01b03858116602483015292935091169063b9496b62906044015f604051808303815f87803b158015611a58575f5ffd5b505af1158015611a6a573d5f5f3e3d5ffd5b50505050505050565b7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e464970154604051639cd07acb60e01b81525f917f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700916001600160a01b0390911690639cd07acb90611ae89087908790600401612288565b6020604051808303815f875af1158015611b04573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611b289190612271565b949350505050565b5f5f8215611b435750600160f81b611b46565b505f5b5f7f9e7b61f58c47dc699ac88507c4f5bb9f121c03808c5676a8078fe583e4649700600181015460405163022f65e760e31b815260048101899052602481018890527fff00000000000000000000000000000000000000000000000000000000000000851660448201529192506001600160a01b03169063117b2f38906064016020604051808303815f875af1158015611be2573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190611c069190612271565b9695505050505050565b5f5f83601f840112611c20575f5ffd5b50813567ffffffffffffffff811115611c37575f5ffd5b602083019150836020828501011115611c4e575f5ffd5b9250929050565b5f5f83601f840112611c65575f5ffd5b50813567ffffffffffffffff811115611c7c575f5ffd5b6020830191508360208260051b8501011115611c4e575f5ffd5b5f5f5f5f5f5f5f5f5f5f5f5f60c08d8f031215611cb1575f5ffd5b67ffffffffffffffff8d351115611cc6575f5ffd5b611cd38e8e358f01611c10565b909c509a5067ffffffffffffffff60208e01351115611cf0575f5ffd5b611d008e60208f01358f01611c10565b909a50985067ffffffffffffffff60408e01351115611d1d575f5ffd5b611d2d8e60408f01358f01611c10565b909850965067ffffffffffffffff60608e01351115611d4a575f5ffd5b611d5a8e60608f01358f01611c55565b909650945067ffffffffffffffff60808e01351115611d77575f5ffd5b611d878e60808f01358f01611c55565b909450925067ffffffffffffffff60a08e01351115611da4575f5ffd5b611db48e60a08f01358f01611c10565b81935080925050509295989b509295989b509295989b565b80356001600160a01b0381168114611de2575f5ffd5b919050565b5f60208284031215611df7575f5ffd5b6108ef82611dcc565b602080825282518282018190525f918401906040840190835b81811015611e37578351835260209384019390920191600101611e19565b509095945050505050565b5f5f5f60408486031215611e54575f5ffd5b611e5d84611dcc565b9250602084013567ffffffffffffffff811115611e78575f5ffd5b611e8486828701611c55565b9497909650939450505050565b5f5f60408385031215611ea2575f5ffd5b611eab83611dcc565b946020939093013593505050565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b60c081525f611ef960c0830189611eb9565b8281036020840152611f0b8189611eb9565b90508281036040840152611f1f8188611eb9565b9050828103606084015280865180835260208301915060208160051b840101602089015f5b83811015611f7657601f19868403018552611f60838351611eb9565b6020958601959093509190910190600101611f44565b505067ffffffffffffffff881660808701529350611f9392505050565b67ffffffffffffffff831660a0830152979650505050505050565b634e487b7160e01b5f52604160045260245ffd5b600181811c90821680611fd657607f821691505b602082108103611ff457634e487b7160e01b5f52602260045260245ffd5b50919050565b601f82111561204157805f5260205f20601f840160051c8101602085101561201f5750805b601f840160051c820191505b8181101561203e575f815560010161202b565b50505b505050565b67ffffffffffffffff83111561205e5761205e611fae565b6120728361206c8354611fc2565b83611ffa565b5f601f8411600181146120a3575f851561208c5750838201355b5f19600387901b1c1916600186901b17835561203e565b5f83815260208120601f198716915b828110156120d257868501358255602094850194600190920191016120b2565b50868210156120ee575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b815167ffffffffffffffff81111561211a5761211a611fae565b61212e816121288454611fc2565b84611ffa565b6020601f821160018114612160575f83156121495750848201515b5f19600385901b1c1916600184901b17845561203e565b5f84815260208120601f198516915b8281101561218f578785015182556020948501946001909201910161216f565b50848210156121ac57868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b634e487b7160e01b5f52603260045260245ffd5b5f5f8335601e198436030181126121e4575f5ffd5b83018035915067ffffffffffffffff8211156121fe575f5ffd5b602001915036819003821315611c4e575f5ffd5b6054811061222e57634e487b7160e01b5f52602160045260245ffd5b9052565b8481526001600160a01b0384166020820152608060408201525f6122596080830185611eb9565b90506122686060830184612212565b95945050505050565b5f60208284031215612281575f5ffd5b5051919050565b828152604081016108ef602083018461221256fea164736f6c634300081b000a",
  "devdoc": {
    "details": "Uses FHEVM to enable encrypted skill matching without decryption",
    "kind": "dev",
    "methods": {
      "authorizeHR(address)": {
        "params": {
          "hr": "HR address to authorize"
        }
      },
      "calculateSkillScore(address,uint256[])": {
        "details": "Performs encrypted addition without decrypting individual levels",
        "params": {
          "candidate": "Candidate address",
          "skillIndices": "Array of skill indices to include in score (0-4)"
        },
        "returns": {
          "_0": "totalScore Encrypted total proficiency score"
        }
      },
      "evaluateSkillMatch(address,uint256)": {
        "details": "Returns encrypted skill level for HR to decrypt and evaluate",
        "params": {
          "candidate": "Candidate address",
          "skillIndex": "Index of the skill to evaluate (0-4)"
        },
        "returns": {
          "_0": "skillLevel Encrypted skill proficiency level"
        }
      },
      "getResumeInfo(address)": {
        "params": {
          "user": "Address of the resume owner"
        }
      },
      "getSkillLevels(address)": {
        "params": {
          "user": "Address of the resume owner"
        }
      },
      "revokeHR(address)": {
        "params": {
          "hr": "HR address to revoke"
        }
      },
      "submitResume(string,string,string,string[],bytes32[],bytes)": {
        "params": {
          "education": "Education experience",
          "inputProof": "Zama input proof for encrypted skill levels",
          "name": "User's name (can be desensitized)",
          "skillLevelsExt": "Array of encrypted skill proficiency levels (max 5)",
          "skillNames": "Array of skill names (max 5)",
          "workExperience": "Work experience"
        }
      },
      "updateResume(string,string,string,string[],bytes32[],bytes)": {
        "params": {
          "education": "Updated education",
          "inputProof": "Zama input proof",
          "name": "Updated name",
          "skillLevelsExt": "Updated encrypted skill levels (max 5)",
          "skillNames": "Updated skill names (max 5)",
          "workExperience": "Updated work experience"
        }
      }
    },
    "title": "Secure Resume Storage Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "authorizeHR(address)": {
        "notice": "Authorize an HR address"
      },
      "calculateSkillScore(address,uint256[])": {
        "notice": "HR function: Calculate total skill score across multiple skills"
      },
      "evaluateSkillMatch(address,uint256)": {
        "notice": "HR function: Evaluate skill match for a specific skill"
      },
      "getResumeInfo(address)": {
        "notice": "Get resume basic info (plaintext data)"
      },
      "getSkillLevels(address)": {
        "notice": "Get encrypted skill levels for a user"
      },
      "getStats()": {
        "notice": "Get contract statistics"
      },
      "hasResume(address)": {
        "notice": "Check if user has submitted a resume"
      },
      "revokeHR(address)": {
        "notice": "Revoke HR authorization"
      },
      "submitResume(string,string,string,string[],bytes32[],bytes)": {
        "notice": "Submit a new resume with encrypted skill data"
      },
      "updateResume(string,string,string,string[],bytes32[],bytes)": {
        "notice": "Update existing resume"
      }
    },
    "notice": "Stores encrypted resume data with FHE-protected skill evaluation",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 39081,
        "contract": "contracts/SecureResume.sol:SecureResume",
        "label": "_resumes",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_struct(Resume)39076_storage)"
      },
      {
        "astId": 39085,
        "contract": "contracts/SecureResume.sol:SecureResume",
        "label": "hrAddresses",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_struct(Resume)39076_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct SecureResume.Resume)",
        "numberOfBytes": "32",
        "value": "t_struct(Resume)39076_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Resume)39076_storage": {
        "encoding": "inplace",
        "label": "struct SecureResume.Resume",
        "members": [
          {
            "astId": 39038,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "name",
            "offset": 0,
            "slot": "0",
            "type": "t_string_storage"
          },
          {
            "astId": 39040,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "education",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          },
          {
            "astId": 39042,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "workExperience",
            "offset": 0,
            "slot": "2",
            "type": "t_string_storage"
          },
          {
            "astId": 39045,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillLevel1",
            "offset": 0,
            "slot": "3",
            "type": "t_userDefinedValueType(euint32)40318"
          },
          {
            "astId": 39048,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillLevel2",
            "offset": 0,
            "slot": "4",
            "type": "t_userDefinedValueType(euint32)40318"
          },
          {
            "astId": 39051,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillLevel3",
            "offset": 0,
            "slot": "5",
            "type": "t_userDefinedValueType(euint32)40318"
          },
          {
            "astId": 39054,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillLevel4",
            "offset": 0,
            "slot": "6",
            "type": "t_userDefinedValueType(euint32)40318"
          },
          {
            "astId": 39057,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillLevel5",
            "offset": 0,
            "slot": "7",
            "type": "t_userDefinedValueType(euint32)40318"
          },
          {
            "astId": 39059,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillName1",
            "offset": 0,
            "slot": "8",
            "type": "t_string_storage"
          },
          {
            "astId": 39061,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillName2",
            "offset": 0,
            "slot": "9",
            "type": "t_string_storage"
          },
          {
            "astId": 39063,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillName3",
            "offset": 0,
            "slot": "10",
            "type": "t_string_storage"
          },
          {
            "astId": 39065,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillName4",
            "offset": 0,
            "slot": "11",
            "type": "t_string_storage"
          },
          {
            "astId": 39067,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillName5",
            "offset": 0,
            "slot": "12",
            "type": "t_string_storage"
          },
          {
            "astId": 39069,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "skillCount",
            "offset": 0,
            "slot": "13",
            "type": "t_uint8"
          },
          {
            "astId": 39071,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "createdAt",
            "offset": 1,
            "slot": "13",
            "type": "t_uint64"
          },
          {
            "astId": 39073,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "updatedAt",
            "offset": 9,
            "slot": "13",
            "type": "t_uint64"
          },
          {
            "astId": 39075,
            "contract": "contracts/SecureResume.sol:SecureResume",
            "label": "exists",
            "offset": 17,
            "slot": "13",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "448"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      },
      "t_userDefinedValueType(euint32)40318": {
        "encoding": "inplace",
        "label": "euint32",
        "numberOfBytes": "32"
      }
    }
  }
}